<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Amber.Primitives</name>
    </assembly>
    <members>
        <member name="T:Amber.Clock.MonotonicTimestamp">
            <summary>
            Represents a timestamp returned by the <see cref="T:Amber.Clock.MonotonicClock"/>. The timestamps are deliberately opaque: Use 
            <see cref="M:Amber.Clock.MonotonicTimestamp.ElapsedTimeFromAToB(Amber.Clock.MonotonicTimestamp,Amber.Clock.MonotonicTimestamp)"/> in order to measure the time difference between them.
            </summary>
        </member>
        <member name="F:Amber.Clock.MonotonicTimestamp.Zero">
            <summary>
            The earliest possible timestamp (e.g. <c>(MonotonicTimestamp) 0L</c>.
            </summary>
        </member>
        <member name="M:Amber.Clock.MonotonicTimestamp.ElapsedTimeFromAToB(Amber.Clock.MonotonicTimestamp,Amber.Clock.MonotonicTimestamp)">
            <summary>
            Determine the amount of time that passed between <paramref name="a"/> and <paramref name="b"/>.
            </summary>
            <param name="a">The start time.</param>
            <param name="b">The end time.</param>
            <returns>The span of time between the two timestamps. If <paramref name="a"/> represents an earlier time compared to
            <paramref name="b"/>, the returned timespan will have a positive value. If <paramref name="a"/> represents a later
            time compared to <paramref name="b"/>, the returned timespan will have a negative value. If <paramref name="a"/> and
            <paramref name="b"/> represent the same time, <see cref="F:System.TimeSpan.Zero"/> will be returned.</returns>
        </member>
        <member name="M:Amber.Clock.MonotonicTimestamp.op_Subtraction(Amber.Clock.MonotonicTimestamp,Amber.Clock.MonotonicTimestamp)">
            <summary>
            Get the time difference between the two timestamps.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>ElapsedTimeFromAToB(rhs, lhs)</c></returns>
        </member>
        <member name="M:Amber.Clock.MonotonicTimestamp.Equals(Amber.Clock.MonotonicTimestamp)">
            <inheritdoc />
        </member>
        <member name="M:Amber.Clock.MonotonicTimestamp.CompareTo(Amber.Clock.MonotonicTimestamp)">
            <inheritdoc />
        </member>
        <member name="M:Amber.Clock.MonotonicTimestamp.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Amber.Clock.MonotonicTimestamp.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Amber.Clock.MonotonicTimestamp.op_Equality(Amber.Clock.MonotonicTimestamp,Amber.Clock.MonotonicTimestamp)">
            <summary>
            See <see cref="M:Amber.Clock.MonotonicTimestamp.Equals(Amber.Clock.MonotonicTimestamp)"/>.
            </summary>
        </member>
        <member name="M:Amber.Clock.MonotonicTimestamp.op_Inequality(Amber.Clock.MonotonicTimestamp,Amber.Clock.MonotonicTimestamp)">
            <summary>
            See <see cref="M:Amber.Clock.MonotonicTimestamp.Equals(Amber.Clock.MonotonicTimestamp)"/>.
            </summary>
        </member>
        <member name="M:Amber.Clock.MonotonicTimestamp.op_GreaterThan(Amber.Clock.MonotonicTimestamp,Amber.Clock.MonotonicTimestamp)">
            <summary>
            Determine whether the left-hand operand represents a later time than the right-hand operand.
            </summary>
            <param name="left">The left-hand operand.</param>
            <param name="right">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="left"/> represents a later time than <paramref name="right"/>.</returns>
        </member>
        <member name="M:Amber.Clock.MonotonicTimestamp.op_LessThan(Amber.Clock.MonotonicTimestamp,Amber.Clock.MonotonicTimestamp)">
            <summary>
            Determine whether the left-hand operand represents an equal or later time than the right-hand operand.
            </summary>
            <param name="left">The left-hand operand.</param>
            <param name="right">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="left"/> represents an equal or later time than <paramref name="right"/>.</returns>
        </member>
        <member name="M:Amber.Clock.MonotonicTimestamp.op_GreaterThanOrEqual(Amber.Clock.MonotonicTimestamp,Amber.Clock.MonotonicTimestamp)">
            <summary>
            Determine whether the left-hand operand represents an earlier time than the right-hand operand.
            </summary>
            <param name="left">The left-hand operand.</param>
            <param name="right">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="left"/> represents an earlier time than <paramref name="right"/>.</returns>
        </member>
        <member name="M:Amber.Clock.MonotonicTimestamp.op_LessThanOrEqual(Amber.Clock.MonotonicTimestamp,Amber.Clock.MonotonicTimestamp)">
            <summary>
            Determine whether the left-hand operand represents an equal or earlier time than the right-hand operand.
            </summary>
            <param name="left">The left-hand operand.</param>
            <param name="right">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="left"/> represents an equal or earlier time than <paramref name="right"/>.</returns>
        </member>
        <member name="M:Amber.Clock.MonotonicTimestamp.op_Explicit(Amber.Clock.MonotonicTimestamp)~System.Int64">
            <summary>
            Convert this timestamp to a <see cref="T:System.Int64"/> so it can be used as a numeric value. The numeric value is only
            useful as a comparand with other converted timestamps, and must not be used as anything else.
            </summary>
        </member>
        <member name="M:Amber.Clock.MonotonicTimestamp.op_Explicit(System.Int64)~Amber.Clock.MonotonicTimestamp">
            <summary>
            Convert a previously-converted <see cref="T:System.Int64"/> back in to a timestamp. The numeric value must be a previously
            casted <see cref="T:Amber.Clock.MonotonicTimestamp"/> and unaltered- there are no meaningful conversions from altered longs
            or longs from other sources.
            </summary>
        </member>
        <member name="T:Amber.Clock.MonotonicClock">
            <summary>
            A clock that always progresses forward in time. Useful for timing/measuring when working with multithreaded environments
            (as <see cref="T:System.Diagnostics.Stopwatch"/> is not threadsafe).
            </summary>
        </member>
        <member name="P:Amber.Clock.MonotonicClock.Now">
            <summary>
            A timestamp representing 'now'. Use <see cref="M:Amber.Clock.MonotonicTimestamp.ElapsedTimeFromAToB(Amber.Clock.MonotonicTimestamp,Amber.Clock.MonotonicTimestamp)"/> to compare two timestamps.
            </summary>
        </member>
        <member name="M:Amber.Clock.MonotonicClock.TimeSince(Amber.Clock.MonotonicTimestamp)">
            <summary>
            Determine how much time elapsed between now and the given <paramref name="timestamp"/>. This method will never
            return a negative <see cref="T:System.TimeSpan"/>. If the given <paramref name="timestamp"/> is in the future,
            <see cref="F:System.TimeSpan.Zero"/> will be returned.
            </summary>
            <param name="timestamp">The timestamp that represents the start-time for this measurement.</param>
            <returns>A <see cref="T:System.TimeSpan"/> that indicates the difference in time between the <see cref="P:Amber.Clock.MonotonicClock.Now"/> and 
            <paramref name="timestamp"/>. Can never be negative.</returns>
        </member>
        <member name="T:Amber.Configuration.ConfigSerializedAttribute">
            <summary>
            When applied to a field or property of a class that extends from <see cref="T:Amber.Configuration.UserConfig"/>, this attribute indicates that
            that field or property should be serialized/deserialized to/from disk when <see cref="M:Amber.Configuration.UserConfig.Serialize(System.String)"/> or
            <see cref="M:Amber.Configuration.UserConfig.Deserialize``1(System.String)"/> is called. Fields and properties in the target type that are not
            annotated with this attribute will be ignored.
            </summary>
        </member>
        <member name="F:Amber.Configuration.ConfigSerializedAttribute.Group">
            <summary>
            The INI-file group that the field this attribute is applied to belongs to.
            </summary>
        </member>
        <member name="F:Amber.Configuration.ConfigSerializedAttribute.Description">
            <summary>
            The description (written to the config output) that applies to the field this attribute is applied to.
            </summary>
        </member>
        <member name="M:Amber.Configuration.ConfigSerializedAttribute.#ctor(System.String,System.String)">
            <summary>
            Create a new <see cref="T:Amber.Configuration.ConfigSerializedAttribute"/> with the given mandatory fields.
            </summary>
            <param name="group">The INI-file group that the field this attribute is applied to belongs to.</param>
            <param name="description">The description (written to the config output) that applies to the field this attribute is applied to.</param>
        </member>
        <member name="T:Amber.Configuration.UserConfig">
            <summary>
            An abstract class that represents a user configuration page (can be serialized/deserialized in a human-readable format to
            disk). Custom configuration classes should derive from this type.
            <para>
            It is possible to save configuration values in classes that derive from this type by calling <see cref="M:Amber.Configuration.UserConfig.Serialize(System.String)"/>.
            Reloading saved values is then possible by calling the static method <see cref="M:Amber.Configuration.UserConfig.Deserialize``1(System.String)"/> on this type.
            </para>
            </summary>
        </member>
        <member name="M:Amber.Configuration.UserConfig.Serialize(System.String)">
            <summary>
            Serialize all the values stored in this configuration object to disk, using the given file name.
            </summary>
            <param name="filePath">The location of the file to write to. Does not need to already exist, but must be a valid file path.</param>
        </member>
        <member name="M:Amber.Configuration.UserConfig.Serialize(System.IO.StreamWriter)">
            <summary>
            Serialize all the data in string format to the given stream writer.
            </summary>
            <param name="streamWriter">The stream writer to serialize to. Must not be null or disposed.</param>
        </member>
        <member name="M:Amber.Configuration.UserConfig.Deserialize``1(System.String)">
            <summary>
            Deserialize the configuration options in the given file in to a new instance of type <typeparamref name="TConfig"/>. The
            given file must already exist. If fields have been added to the <typeparamref name="TConfig"/> type since the config
            file was generated, the default values defined in the class will be used for those fields. If fields have been removed
            since the file was generated, those fields will be ignored (and a warning will be displayed via the <see cref="T:Amber.Log"/>).
            </summary>
            <typeparam name="TConfig">The <see cref="T:Amber.Configuration.UserConfig"/> type that is represented by the given file. The type must declare a
            public no-args constructor.</typeparam>
            <param name="filePath">The path to the file that contains previously deserialized config data. Must exist.</param>
            <returns>A new <typeparamref name="TConfig"/> whose fields have been set to the values represented in the given
            <paramref name="filePath"/>.</returns>
        </member>
        <member name="M:Amber.Configuration.UserConfig.Deserialize``1(System.IO.StreamReader)">
            <summary>
            Deserialize the configuration options in the given stream in to a new instance of type <typeparamref name="TConfig"/>. The
            stream should be in text-based INI-format. If any fields in the <typeparamref name="TConfig"/> type are not specified in
            the stream the default values defined in the class will be used for those fields. If fields that don't exist in the
            <typeparamref name="TConfig"/> type are specified in the stream, those fields will be ignored (and a warning will be
            displayed via the <see cref="T:Amber.Log"/>).
            </summary>
            <typeparam name="TConfig">The <see cref="T:Amber.Configuration.UserConfig"/> type that is represented by the given file. The type must declare a
            public no-args constructor.</typeparam>
            <param name="streamReader">A stream reader that is ready to read serialized data from an underlying stream
            in INI text format.</param>
            <returns>A new <typeparamref name="TConfig"/> whose fields have been set to the values represented in the given stream.</returns>
        </member>
        <member name="M:Amber.Configuration.UserConfig.AddSerializationSupportForType``1(System.Func{``0,System.String},System.Func{System.String,``0})">
            <summary>
            Add custom serialization support for the given type <typeparamref name="T"/>. Even if a default serialization behaviour
            exists for the type, this serializer behaviour will be used instead. 
            </summary>
            <typeparam name="T">The type to be converted to/from string representation.</typeparam>
            <param name="serializerFunc">A function that takes a <typeparamref name="T"/> and converts it to a string
            representation for serialization. The <typeparamref name="T"/> that is passed in is guaranteed to never be null.</param>
            <param name="deserializerFunc">A function that takes a string representation of a <typeparamref name="T"/> instance
            and converts it in to an actual <typeparamref name="T"/>. This function is permitted to return null.</param>
        </member>
        <member name="T:Amber.Extensions">
            <summary>
            Static class containing various extension methods for use throughout Amber products.
            </summary>
        </member>
        <member name="M:Amber.Extensions.TestWritePermissions(System.IO.DirectoryInfo)">
            <summary>
            Determine whether the current application can create / write to this directory.
            </summary>
            <param name="this">The extended DirectoryInfo.</param>
            <returns>True if the application can create and write to files on this directory, false if not.</returns>
        </member>
        <member name="T:Amber.Extensions.RWLSToken">
            <summary>
            A disposable struct that allows entering/exist read/write locks via the using pattern.
            See <see cref="M:Amber.Extensions.UsingReadLockToken(System.Threading.ReaderWriterLockSlim)"/>/<see cref="M:Amber.Extensions.UsingWriteLockToken(System.Threading.ReaderWriterLockSlim)"/>.
            </summary>
        </member>
        <member name="M:Amber.Extensions.RWLSToken.Dispose">
            <summary>
            Exit the <see cref="T:System.Threading.ReaderWriterLockSlim"/>.
            </summary>
        </member>
        <member name="M:Amber.Extensions.UsingReadLockToken(System.Threading.ReaderWriterLockSlim)">
            <summary>
            Enters the read lock of this <see cref="T:System.Threading.ReaderWriterLockSlim"/> and return a token that, upon disposal, exits the lock.
            Allows this <see cref="T:System.Threading.ReaderWriterLockSlim"/> to be used with the using-pattern.
            </summary>
            <returns>A <see cref="T:Amber.Extensions.RWLSToken"/>.</returns>
        </member>
        <member name="M:Amber.Extensions.UsingWriteLockToken(System.Threading.ReaderWriterLockSlim)">
            <summary>
            Enters the write lock of this <see cref="T:System.Threading.ReaderWriterLockSlim"/> and return a token that, upon disposal, exits the lock.
            Allows this <see cref="T:System.Threading.ReaderWriterLockSlim"/> to be used with the using-pattern.
            </summary>
            <returns>A <see cref="T:Amber.Extensions.RWLSToken"/>.</returns>
        </member>
        <member name="M:Amber.Extensions.Times(System.TimeSpan,System.Double)">
            <summary>
            Multiply this <see cref="T:System.TimeSpan"/> by the given <paramref name="coefficient"/>. For example, if <paramref name="this"/>
            TimeSpan represents a period of 3 hours, a <paramref name="coefficient"/> of <c>2.5d</c> will result in a returned
            TimeSpan that represents 7.5 hours.
            </summary>
            <param name="this">The extended TimeSpan.</param>
            <param name="coefficient">The amount to multiply this TimeSpan by. Can be any valid number (negative, lower than one,
            greater than one, etc.).</param>
            <returns>A new <see cref="T:System.TimeSpan"/> that represents <paramref name="this"/> TimeSpan multiplied by
            the given <paramref name="coefficient"/>.</returns>
        </member>
        <member name="M:Amber.Extensions.ToHumanReadableString(System.TimeSpan)">
            <summary>
            Calls <see cref="M:Amber.DateAndTimeUtils.ConvertToHumanReadableString(System.TimeSpan)"/> with this TimeSpan.
            </summary>
            <param name="this">The extended TimeSpan.</param>
            <returns>This timespan converted in to a human-readable string format 
            (e.g. "<c>4 days, 10 hours, 30 mins, 10 secs, 500 ms</c>").</returns>
        </member>
        <member name="F:Amber.Extensions.ISO_8601_DATE_TIME_FORMAT">
            <summary>
            The <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a> date/time format string.
            </summary>
        </member>
        <member name="M:Amber.Extensions.ToISO8601String(System.DateTime)">
            <summary>
            Convert this <see cref="T:System.DateTime"/> to an <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a> compliant
            string. The value given will be in the universal/UTC timezone.
            </summary>
            <param name="this">The extended DateTime.</param>
            <returns>A string in the format specified by <see cref="F:Amber.Extensions.ISO_8601_DATE_TIME_FORMAT"/>.</returns>
        </member>
        <member name="M:Amber.Extensions.ToISO8601String(System.DateTimeOffset)">
            <summary>
            Convert this <see cref="T:System.DateTimeOffset"/> to an <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a> compliant
            string. The value given will be in the universal/UTC timezone.
            </summary>
            <param name="this">The extended DateTimeOffset.</param>
            <returns>A string in the format specified by <see cref="F:Amber.Extensions.ISO_8601_DATE_TIME_FORMAT"/>.</returns>
        </member>
        <member name="M:Amber.Extensions.Batch``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Batch the given source enumerable in to a number of sub-sequences, each of length <paramref name="batchSize"/>.
            </summary>
            <typeparam name="T">The type of element contained in the enumerable.</typeparam>
            <param name="this">The extended enumerable.</param>
            <param name="batchSize">The size of each batch. Must be greater than 0. The last batch will have fewer elements
            than the others if this is not a perfect factor of the number of elements in the source enumerable.</param>
            <returns>An enumerable of 'batches' (<see cref="T:System.Collections.Generic.IEnumerable`1"/>s), each containing <paramref name="batchSize"/>
            elements from the source sequence. Order is preserved.</returns>
        </member>
        <member name="T:Amber.Graphics.HSLColor">
            <summary>
            Represent a color in the Hue-Saturation-Luminosity color space.
            </summary>
        </member>
        <member name="F:Amber.Graphics.HSLColor.FIELD_MAX">
            <summary>
            Max value for <see cref="P:Amber.Graphics.HSLColor.Hue"/>, <see cref="P:Amber.Graphics.HSLColor.Saturation"/>, or <see cref="P:Amber.Graphics.HSLColor.Luminosity"/>;
            </summary>
        </member>
        <member name="P:Amber.Graphics.HSLColor.Hue">
            <summary>
            Hue value for this color, between <c>0d</c> and <see cref="F:Amber.Graphics.HSLColor.FIELD_MAX"/>.
            </summary>
        </member>
        <member name="P:Amber.Graphics.HSLColor.Saturation">
            <summary>
            Saturation value for this color, between <c>0d</c> and <see cref="F:Amber.Graphics.HSLColor.FIELD_MAX"/>.
            </summary>
        </member>
        <member name="P:Amber.Graphics.HSLColor.Luminosity">
            <summary>
            Luminosity value for this color, between <c>0d</c> and <see cref="F:Amber.Graphics.HSLColor.FIELD_MAX"/>.
            </summary>
        </member>
        <member name="M:Amber.Graphics.HSLColor.op_Implicit(Amber.Graphics.HSLColor)~System.Drawing.Color">
            <summary>
            Convert an <see cref="T:Amber.Graphics.HSLColor"/> to a <see cref="T:System.Drawing.Color"/>.
            </summary>
            <param name="hslColor">The <see cref="T:Amber.Graphics.HSLColor"/> to convert. Must not be null.</param>
        </member>
        <member name="M:Amber.Graphics.HSLColor.op_Implicit(System.Drawing.Color)~Amber.Graphics.HSLColor">
            <summary>
            Convert the given <paramref name="color"/> in to an <see cref="T:Amber.Graphics.HSLColor"/>.
            </summary>
            <param name="color">The <see cref="T:System.Drawing.Color"/> to convert.</param>
        </member>
        <member name="M:Amber.Graphics.HSLColor.SetRGB(System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets the value of this color according to the given RGB values.
            </summary>
            <param name="red">The red component's value, between <c>0</c> and <c>255</c>.</param>
            <param name="green">The green component's value, between <c>0</c> and <c>255</c>.</param>
            <param name="blue">The blue component's value, between <c>0</c> and <c>255</c>.</param>
        </member>
        <member name="M:Amber.Graphics.HSLColor.GetRGB">
            <summary>
            Gets the RGB value of this color according to the currently set values for <see cref="P:Amber.Graphics.HSLColor.Hue"/>, <see cref="P:Amber.Graphics.HSLColor.Saturation"/>,
            and <see cref="P:Amber.Graphics.HSLColor.Luminosity"/>.
            </summary>
            <returns>A new <see cref="T:System.Drawing.Color"/> that represents this <see cref="T:Amber.Graphics.HSLColor"/> in RGB color space.</returns>
        </member>
        <member name="M:Amber.Graphics.HSLColor.#ctor">
            <summary>
            Create a new HSLColor with <see cref="P:Amber.Graphics.HSLColor.Hue"/> <see cref="P:Amber.Graphics.HSLColor.Saturation"/> and <see cref="P:Amber.Graphics.HSLColor.Luminosity"/> values of <c>0d</c>.
            </summary>
        </member>
        <member name="M:Amber.Graphics.HSLColor.#ctor(System.Drawing.Color)">
            <summary>
            Create a new HSLColor with values translated accordingly from the given RGB <paramref name="color"/>.
            </summary>
            <param name="color">The color to initialize this HSLColor with.</param>
        </member>
        <member name="M:Amber.Graphics.HSLColor.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Create a new HSLColor initialized with the given values for <see cref="P:Amber.Graphics.HSLColor.Hue"/> <see cref="P:Amber.Graphics.HSLColor.Saturation"/>
            and <see cref="P:Amber.Graphics.HSLColor.Luminosity"/>.
            </summary>
            <param name="hue">Hue value for this color, between <c>0d</c> and <see cref="F:Amber.Graphics.HSLColor.FIELD_MAX"/>.</param>
            <param name="saturation">Saturation value for this color, between <c>0d</c> and <see cref="F:Amber.Graphics.HSLColor.FIELD_MAX"/>.</param>
            <param name="luminosity">Luminosity value for this color, between <c>0d</c> and <see cref="F:Amber.Graphics.HSLColor.FIELD_MAX"/>.</param>
        </member>
        <member name="M:Amber.Graphics.HSLColor.ToString">
            <summary>
            Returns a string representing this HSLColor.
            </summary>
            <returns>A string in the form "H: hue S: saturation L: luminosity".</returns>
        </member>
        <member name="M:Amber.Graphics.HSLColor.ToRGBString">
            <summary>
            Returns a string representing this HSLColor in terms of its values in basic RGB color space.
            </summary>
            <returns>A string in the form "R: r G: g B: b".</returns>
        </member>
        <member name="T:Amber.Infrastructure.ScadaIdentity">
            <summary>
            Represents a unique identity for any given SCADA / infrastructure entity (such as a flywheel, inverter, etc.).
            </summary>
        </member>
        <member name="P:Amber.Infrastructure.ScadaIdentity.UUID">
            <summary>
            The universally unique identifier for this SCADA entity.
            </summary>
        </member>
        <member name="M:Amber.Infrastructure.ScadaIdentity.#ctor(System.String)">
            <summary>
            Create a new identity with the given universally unique identifier string.
            </summary>
            <param name="uuid">The UUID. Must not be null.</param>
        </member>
        <member name="M:Amber.Infrastructure.ScadaIdentity.Equals(Amber.Infrastructure.ScadaIdentity)">
            <inheritdoc />
        </member>
        <member name="M:Amber.Infrastructure.ScadaIdentity.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Amber.Infrastructure.ScadaIdentity.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Amber.Infrastructure.ScadaIdentity.op_Equality(Amber.Infrastructure.ScadaIdentity,Amber.Infrastructure.ScadaIdentity)">
            <summary>
            <see cref="M:Amber.Infrastructure.ScadaIdentity.Equals(Amber.Infrastructure.ScadaIdentity)"/>.
            </summary>
        </member>
        <member name="M:Amber.Infrastructure.ScadaIdentity.op_Inequality(Amber.Infrastructure.ScadaIdentity,Amber.Infrastructure.ScadaIdentity)">
            <summary>
            <see cref="M:Amber.Infrastructure.ScadaIdentity.Equals(Amber.Infrastructure.ScadaIdentity)"/>.
            </summary>
        </member>
        <member name="T:Amber.IO.ByteSize">
            <summary>
            Represents a number of bytes (e.g. the size of a file, or amount of memory allocated, etc.).
            </summary>
        </member>
        <member name="F:Amber.IO.ByteSize.MaxValue">
            <summary>
            Maximum possible size representable by this type.
            </summary>
        </member>
        <member name="F:Amber.IO.ByteSize.MinValue">
            <summary>
            Minimum possible size (negative) representable by this type.
            </summary>
        </member>
        <member name="F:Amber.IO.ByteSize.Zero">
            <summary>
            Represents a size of exactly zero bytes.
            </summary>
        </member>
        <member name="F:Amber.IO.ByteSize.BytesInAKibibyte">
            <summary>
            The number of bytes in a Kibibyte (commonly referred to erroneously as a Kilobyte).
            </summary>
        </member>
        <member name="F:Amber.IO.ByteSize.BytesInAMebibyte">
            <summary>
            The number of bytes in a Mebibyte (commonly referred to erroneously as a Megabyte).
            </summary>
        </member>
        <member name="F:Amber.IO.ByteSize.BytesInAGibibyte">
            <summary>
            The number of bytes in a Gibibyte (commonly referred to erroneously as a Gigabyte).
            </summary>
        </member>
        <member name="F:Amber.IO.ByteSize.BytesInATebibyte">
            <summary>
            The number of bytes in a Tebibyte (commonly referred to erroneously as a Terabyte).
            </summary>
        </member>
        <member name="F:Amber.IO.ByteSize.InBytes">
            <summary>
            The value of this ByteSize in bytes.
            </summary>
        </member>
        <member name="P:Amber.IO.ByteSize.InKibibytes">
            <summary>
            The number of KiB that this ByteSize represents.
            </summary>
            <seealso cref="F:Amber.IO.ByteSize.BytesInAKibibyte"/>
        </member>
        <member name="P:Amber.IO.ByteSize.InMebibytes">
            <summary>
            The number of MiB that this ByteSize represents.
            </summary>
            <seealso cref="F:Amber.IO.ByteSize.BytesInAMebibyte"/>
        </member>
        <member name="P:Amber.IO.ByteSize.InGibibytes">
            <summary>
            The number of GiB that this ByteSize represents.
            </summary>
            <seealso cref="F:Amber.IO.ByteSize.BytesInAGibibyte"/>
        </member>
        <member name="P:Amber.IO.ByteSize.InTebibytes">
            <summary>
            The number of TiB that this ByteSize represents.
            </summary>
            <seealso cref="F:Amber.IO.ByteSize.BytesInATebibyte"/>
        </member>
        <member name="M:Amber.IO.ByteSize.#ctor(System.Int64)">
            <summary>
            Creates a new ByteSize with the specified number of bytes.
            </summary>
            <param name="numBytes">The number of bytes that this ByteSize represents. May be negative.</param>
        </member>
        <member name="M:Amber.IO.ByteSize.#ctor(System.Int64,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates a new ByteSize with the chosen inputs. The resultant value for <see cref="F:Amber.IO.ByteSize.InBytes"/> will be the sum of the provided
            parameters.
            </summary>
            <param name="numBytes">A number of bytes to add.</param>
            <param name="numKibibytes">A number of KiB to add.</param>
            <param name="numMebibytes">A number of MiB to add.</param>
            <param name="numGibibytes">A number of GiB to add.</param>
            <param name="numTebibytes">A number of TiB to add.</param>
        </member>
        <member name="M:Amber.IO.ByteSize.ToString">
            <summary>
            Returns a cleanly-formatted string representation of the value this ByteSize represents.
            </summary>
            <returns>
            "X Y" where X is a value in units 'Y', and Y is the largest sized byte-unit that this ByteSize represents at least
            one of.
            </returns>
        </member>
        <member name="M:Amber.IO.ByteSize.Equals(Amber.IO.ByteSize)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Amber.IO.ByteSize.Equals(System.Object)">
            <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
            <returns>
            true if <paramref name="obj"/> and this instance are the same type and represent the same value; otherwise, false. 
            </returns>
            <param name="obj">The object to compare with the current instance. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:Amber.IO.ByteSize.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Amber.IO.ByteSize.CompareTo(Amber.IO.ByteSize)">
            <summary>
            Compares the current object with another object of the same type.
            </summary>
            <returns>
            A value that indicates the relative order of the objects being compared. The return value has the following meanings: Value Meaning Less than zero This object is less than the <paramref name="other"/> parameter.Zero This object is equal to <paramref name="other"/>. Greater than zero This object is greater than <paramref name="other"/>. 
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Amber.IO.ByteSize.op_Equality(Amber.IO.ByteSize,Amber.IO.ByteSize)">
            <summary>
            Determines whether the two ByteSizes are the same.
            </summary>
            <param name="left">The first operand.</param>
            <param name="right">The second operand.</param>
            <returns>True if both operands have the same value for <see cref="F:Amber.IO.ByteSize.InBytes"/>.</returns>
        </member>
        <member name="M:Amber.IO.ByteSize.op_Inequality(Amber.IO.ByteSize,Amber.IO.ByteSize)">
            <summary>
            Determines whether the two ByteSizes are not the same.
            </summary>
            <param name="left">The first operand.</param>
            <param name="right">The second operand.</param>
            <returns>True if both operands have different values for <see cref="F:Amber.IO.ByteSize.InBytes"/>.</returns>
        </member>
        <member name="M:Amber.IO.ByteSize.op_Addition(Amber.IO.ByteSize,Amber.IO.ByteSize)">
            <summary>
            Returns a new ByteSize that is the two operands' sizes summed together.
            </summary>
            <param name="lhs">The first operand.</param>
            <param name="rhs">The second operand.</param>
            <returns>The equivalent to <c>new ByteSize(lhs.InBytes + rhs.InBytes)</c>.</returns>
        </member>
        <member name="M:Amber.IO.ByteSize.op_Subtraction(Amber.IO.ByteSize,Amber.IO.ByteSize)">
            <summary>
            Returns a new ByteSize that is the difference of the two operands' sizes.
            </summary>
            <param name="lhs">The first operand.</param>
            <param name="rhs">The second operand.</param>
            <returns>The equivalent to <c>new ByteSize(lhs.InBytes - rhs.InBytes)</c>.</returns>
        </member>
        <member name="M:Amber.IO.ByteSize.op_GreaterThan(Amber.IO.ByteSize,Amber.IO.ByteSize)">
            <summary>
            Ascertains whether the first operand represents a larger size than the second.
            </summary>
            <param name="lhs">The first operand.</param>
            <param name="rhs">The second operand.</param>
            <returns>The equivalent to <c>lhs.InBytes &gt; rhs.InBytes</c>.</returns>
        </member>
        <member name="M:Amber.IO.ByteSize.op_LessThan(Amber.IO.ByteSize,Amber.IO.ByteSize)">
            <summary>
            Ascertains whether the first operand represents a smaller size than the second.
            </summary>
            <param name="lhs">The first operand.</param>
            <param name="rhs">The second operand.</param>
            <returns>The equivalent to <c>lhs.InBytes &lt; rhs.InBytes</c>.</returns>
        </member>
        <member name="M:Amber.IO.ByteSize.op_GreaterThanOrEqual(Amber.IO.ByteSize,Amber.IO.ByteSize)">
            <summary>
            Ascertains whether the first operand represents a larger or equal size compared to the second.
            </summary>
            <param name="lhs">The first operand.</param>
            <param name="rhs">The second operand.</param>
            <returns>The equivalent to <c>lhs.InBytes &gt;= rhs.InBytes</c>.</returns>
        </member>
        <member name="M:Amber.IO.ByteSize.op_LessThanOrEqual(Amber.IO.ByteSize,Amber.IO.ByteSize)">
            <summary>
            Ascertains whether the first operand represents a smaller or equal size compared to the second.
            </summary>
            <param name="lhs">The first operand.</param>
            <param name="rhs">The second operand.</param>
            <returns>The equivalent to <c>lhs.InBytes &lt;= rhs.InBytes</c>.</returns>
        </member>
        <member name="M:Amber.IO.ByteSize.op_Multiply(Amber.IO.ByteSize,System.Int64)">
            <summary>
            Returns a new ByteSize that is the size of the first operand multiplied by the second.
            </summary>
            <param name="lhs">The original size.</param>
            <param name="rhs">The multiplicative factor.</param>
            <returns>The equivalent to <c>new ByteSize(lhs.InBytes * rhs)</c>.</returns>
        </member>
        <member name="M:Amber.IO.ByteSize.op_Multiply(System.Int64,Amber.IO.ByteSize)">
            <summary>
            Returns a new ByteSize that is the size of the second operand multiplied by the first.
            </summary>
            <param name="lhs">The multiplicative factor.</param>
            <param name="rhs">The original size.</param>
            <returns>The equivalent to <c>new ByteSize(lhs * rhs.InBytes)</c>.</returns>
        </member>
        <member name="M:Amber.IO.ByteSize.op_Division(Amber.IO.ByteSize,System.Int64)">
            <summary>
            Returns a new ByteSize that is the size of the first operand divided by the second.
            </summary>
            <param name="lhs">The original size.</param>
            <param name="rhs">The divisive factor.</param>
            <returns>The equivalent to <c>new ByteSize(lhs.InBytes / rhs)</c>.</returns>
        </member>
        <member name="M:Amber.IO.ByteSize.op_Implicit(Amber.IO.ByteSize)~System.Int64">
            <summary>
            Returns the byte size of the supplied operand as a long.
            </summary>
            <param name="operand">The ByteSize.</param>
            <returns>The equivalent to <c>operand.InBytes</c>.</returns>
        </member>
        <member name="M:Amber.IO.ByteSize.op_Implicit(System.Int64)~Amber.IO.ByteSize">
            <summary>
            Returns a ByteSize that is the equivalent to the number of bytes supplied as the operand.
            </summary>
            <param name="operand">The number of bytes.</param>
            <returns>The equivalent to <c>new ByteSize(operand)</c>.</returns>
        </member>
        <member name="T:Amber.IO.DuplexStream`1">
            <summary>
            Represents a two-way observable stream.
            </summary>
            <typeparam name="T">The data type passed via the streams.</typeparam>
        </member>
        <member name="P:Amber.IO.DuplexStream`1.FromUpstream">
            <summary>
            An <see cref="T:System.IObservable`1"/> stream that represents data being pushed from the 'up'stream endpoint. Data is pushed
            to this observable via the <see cref="P:Amber.IO.DuplexStream`1.ToDownstream"/> <see cref="T:System.IObserver`1"/>.
            </summary>
        </member>
        <member name="P:Amber.IO.DuplexStream`1.FromDownstream">
            <summary>
            An <see cref="T:System.IObservable`1"/> stream that represents data being pushed from the 'down'stream endpoint. Data is pushed
            to this observable via the <see cref="P:Amber.IO.DuplexStream`1.ToUpstream"/> <see cref="T:System.IObserver`1"/>.
            </summary>
        </member>
        <member name="P:Amber.IO.DuplexStream`1.ToUpstream">
            <summary>
            An <see cref="T:System.IObserver`1"/> that represents an entry point for data to be pushed to the 'up'stream endpoint.
            Data pushed will be delivered to observers of the <see cref="P:Amber.IO.DuplexStream`1.FromDownstream"/> <see cref="T:System.IObservable`1"/>.
            </summary>
        </member>
        <member name="P:Amber.IO.DuplexStream`1.ToDownstream">
            <summary>
            An <see cref="T:System.IObserver`1"/> that represents an entry point for data to be pushed to the 'down'stream endpoint.
            Data pushed will be delivered to observers of the <see cref="P:Amber.IO.DuplexStream`1.FromUpstream"/> <see cref="T:System.IObservable`1"/>.
            </summary>
        </member>
        <member name="M:Amber.IO.DuplexStream`1.Dispose">
            <summary>
            Disposes the two internal subjects to this stream; thereby causing all exposed streams to terminate.
            </summary>
        </member>
        <member name="T:Amber.IO.ITextProvider">
            <summary>
            Represents an object that provides text upon "pull".
            </summary>
        </member>
        <member name="M:Amber.IO.ITextProvider.TakeChar">
            <summary>
            Take a single character from this text provider.
            </summary>
            <returns>The next character in the stream or sequence.</returns>
        </member>
        <member name="M:Amber.IO.ITextProvider.TakeLine">
            <summary>
            Take a discrete line of text from this text provider.
            </summary>
            <returns>The next line of text in the stream or sequence.</returns>
        </member>
        <member name="M:Amber.IO.ITextProvider.TakeText(System.Char[],System.Int32,System.Int32)">
            <summary>
            Copy up to the next <paramref name="max"/> characters from this stream or sequence in to the provided
            <paramref name="target"/> array.
            </summary>
            <param name="target">The target array.</param>
            <param name="startIndex">The index of the first character to be overwritten with the new data.</param>
            <param name="max">The maximum number of characters to write.</param>
            <returns>The actual number of characters written.</returns>
        </member>
        <member name="T:Amber.IO.ITextReceiver">
            <summary>
            Represents an object that can receive/handle text.
            </summary>
        </member>
        <member name="M:Amber.IO.ITextReceiver.HandleText(System.String)">
            <summary>
            Tells this receiver to handle the given text.
            </summary>
            <param name="data">The text to handle.</param>
        </member>
        <member name="M:Amber.IO.ITextReceiver.HandleLine(System.String)">
            <summary>
            Tells this receiver to handle the given text (and treat it as a discrete line).
            </summary>
            <param name="data">The line of text to handle.</param>
        </member>
        <member name="M:Amber.IO.ITextReceiver.HandleText(System.Char[],System.Int32,System.Int32)">
            <summary>
            Tells this receiver to handle the given character array.
            </summary>
            <param name="data">The array containing the text to be handled.</param>
            <param name="startIndex">The index of the first character in the array to be handled.</param>
            <param name="count">The number of characters to be handled.</param>
        </member>
        <member name="T:Amber.IO.RollingFileWriter">
            <summary>
            An <see cref="T:Amber.IO.ITextReceiver"/> that automatically rotates files in the target directory according to the configured parameters.
            </summary>
            <remarks>
            <para>
            When the currently open file reaches the <see cref="P:Amber.IO.RollingFileWriter.MaxFileSizeSpace"/> or <see cref="P:Amber.IO.RollingFileWriter.MaxFileSizeTime"/> it is flushed/closed,
            and a new file is opened for further writes.
            The default configuration for a <see cref="T:Amber.IO.RollingFileWriter"/> rolls over files once every four hours, with no upper limit on
            file size.
            </para>
            <para>
            Rolled-over files in the target directory can also be automatically deleted according to given parameters. Any files that are older
            than the <see cref="P:Amber.IO.RollingFileWriter.MaxDirectorySizeTime"/> will be deleted. Also, if the combined size of all rollover files exceeds
            <see cref="P:Amber.IO.RollingFileWriter.MaxDirectorySizeSpace"/>, the oldest files will be deleted until the limit is reached again. Finally, a hard maximum
            number of rollover files in the target directory can be set with <see cref="P:Amber.IO.RollingFileWriter.MaxDirectoryFileCount"/>.
            The default configuration for a <see cref="T:Amber.IO.RollingFileWriter"/> does not ever delete files from the target directory.
            </para>
            </remarks>
        </member>
        <member name="F:Amber.IO.RollingFileWriter.FileTimestampFormat">
            <summary>
            The string format used for timestamps in rolled-over files.
            </summary>
            <seealso cref="M:Amber.IO.RollingFileWriter.GetFileTimestamp(System.DateTime)"/>
        </member>
        <member name="F:Amber.IO.RollingFileWriter.FileHeader">
            <summary>
            The file header written as the first line in every file. Will be <c>null</c> if no header is to be supplied.
            Does not contribute to <see cref="P:Amber.IO.RollingFileWriter.MaxFileSizeSpace"/>.
            </summary>
        </member>
        <member name="P:Amber.IO.RollingFileWriter.MaxFileSizeSpace">
            <summary>
            The maximum size of the currently open file. When the file exceeds this size, it will be rolled-over (it will be
            flushed/saved to disk, and the next file will be created). Defaults to <see cref="F:Amber.IO.ByteSize.MaxValue"/>.
            </summary>
        </member>
        <member name="P:Amber.IO.RollingFileWriter.MaxFileSizeTime">
            <summary>
            The maximum amount of time the currently open file will be open for before it is rolled-over
            (flushed/saved to disk, and the next file will be created). Defaults to 4 hours.
            </summary>
        </member>
        <member name="P:Amber.IO.RollingFileWriter.MaxDirectorySizeSpace">
            <summary>
            The maximum amount of combined space that rolled-over files are allowed to take on the target directory. When the
            combined space of rolled-over files exceeds this limits, the oldest files will be deleted. Defaults to
            <see cref="F:Amber.IO.ByteSize.MaxValue"/>.
            </summary>
        </member>
        <member name="P:Amber.IO.RollingFileWriter.MaxDirectorySizeTime">
            <summary>
            The maximum age of rolled-over files permitted in the target directory. Rolled-over files that are older than
            this limit will be deleted. Defaults to <see cref="F:System.TimeSpan.MaxValue"/>.
            </summary>
        </member>
        <member name="P:Amber.IO.RollingFileWriter.MaxDirectoryFileCount">
            <summary>
            The maximum permitted number of rolled-over files in the target directory. When this limit is exceeded, the oldest
            files will be deleted. Defaults to <see cref="F:System.Int32.MaxValue"/>.
            </summary>
        </member>
        <member name="P:Amber.IO.RollingFileWriter.AutoFlush">
            <summary>
            If true, data will be immediately flushed to disk when written.
            </summary>
        </member>
        <member name="P:Amber.IO.RollingFileWriter.CurrentFilePath">
            <summary>
            Returns the fill path of the currently open file.
            </summary>
        </member>
        <member name="P:Amber.IO.RollingFileWriter.CurrentFileSizeSpace">
            <summary>
            The amount of data written so far to the currently-open file.
            </summary>
        </member>
        <member name="P:Amber.IO.RollingFileWriter.CurrentFileSizeTime">
            <summary>
            The time elapsed since the currently-open file was opened.
            </summary>
        </member>
        <member name="M:Amber.IO.RollingFileWriter.#ctor(System.String,System.String)">
            <summary>
            Create a new rolling file writer that writes to the given <paramref name="directoryPath"/>
            with the given <paramref name="fileName"/>.
            </summary>
            <param name="directoryPath">The target directory to which files will be written.</param>
            <param name="fileName">The 'base' name of the file used. For example, if this filename is "myFile.txt" then
            files will be saved with names like "myFile.2017-07-17__17-54-20.txt".</param>
        </member>
        <member name="M:Amber.IO.RollingFileWriter.#ctor(System.String,System.String,System.String)">
            <summary>
            Create a new rolling file writer that writes to the given <paramref name="directoryPath"/>
            with the given <paramref name="fileName"/>.
            </summary>
            <param name="directoryPath">The target directory to which files will be written.</param>
            <param name="fileName">The 'base' name of the file used. For example, if this filename is "myFile.txt" then
            files will be saved with names like "myFile.2017-07-17__17-54-20.txt".</param>
            <param name="fileHeader">The header that will be written as the first line at the top of every rolled over file.</param>
        </member>
        <member name="M:Amber.IO.RollingFileWriter.GetFileTimestamp(System.DateTime)">
            <summary>
            Turn the provided <paramref name="dateTime"/> in to a string that uses the same format used by RollingFileWriters
            to save files.
            </summary>
            <param name="dateTime">The <see cref="T:System.DateTime"/> to get the timestamp for. Will be converted to local time.</param>
            <returns>A string in the format specified by <see cref="F:Amber.IO.RollingFileWriter.FileTimestampFormat"/>.</returns>
        </member>
        <member name="M:Amber.IO.RollingFileWriter.WriteLine(System.String)">
            <summary>
            Write a line to this file.
            </summary>
            <param name="data">The data to write. Must not be null.</param>
        </member>
        <member name="M:Amber.IO.RollingFileWriter.Write(System.String)">
            <summary>
            Writes the string to this file.
            </summary>
            <param name="data">The data to write. Must not be null.</param>
        </member>
        <member name="M:Amber.IO.RollingFileWriter.Write(System.Char[],System.Int32,System.Int32)">
            <summary>
            Writes the characters to this file.
            </summary>
            <param name="data">The data to write. Must not be null.</param>
            <param name="startIndex">The first character in the array to begin copying from.</param>
            <param name="count">The number of characters in the array to copy.</param>
        </member>
        <member name="M:Amber.IO.RollingFileWriter.RescanDirectory">
            <summary>
            Force this writer to rescan the target directory. This will also cause the writer to delete files that exceed the
            <see cref="P:Amber.IO.RollingFileWriter.MaxDirectorySizeTime"/>, <see cref="P:Amber.IO.RollingFileWriter.MaxDirectorySizeSpace"/>, or <see cref="P:Amber.IO.RollingFileWriter.MaxDirectoryFileCount"/> limits.
            </summary>
        </member>
        <member name="M:Amber.IO.RollingFileWriter.Rollover">
            <summary>
            Force the writer to flush and close the current file and open one, even if the <see cref="P:Amber.IO.RollingFileWriter.MaxFileSizeSpace"/>
            or <see cref="P:Amber.IO.RollingFileWriter.MaxFileSizeTime"/> limits have not been met.
            </summary>
        </member>
        <member name="M:Amber.IO.RollingFileWriter.Dispose">
            <summary>
            Flush and close the current file, and stop writing. Disposes any resources held by this writer.
            </summary>
        </member>
        <member name="M:Amber.IO.RollingFileWriter.GetAllRolloverFiles">
            <summary>
            Get all files in the target directory that are directly managed by this writer.
            </summary>
            <returns>An array of all files found in the target directory that match the original filename. Never returns null.</returns>
        </member>
        <member name="M:Amber.IO.RollingFileWriter.GetAllRolloverFiles(System.String,System.String)">
            <summary>
            Get all files in the <paramref name="targetDirectory"/> that match the given <paramref name="originalFilename"/>,
            as would be saved by a <see cref="T:Amber.IO.RollingFileWriter"/> (e.g. ignoring timestamps).
            </summary>
            <param name="targetDirectory">The target directory to search files for. Must not be null.</param>
            <param name="originalFilename">The original filename without timestamps (e.g. 'abc.def'). Must not be null.</param>
            <returns>An array of all files found in the <paramref name="targetDirectory"/> that match the
            <paramref name="originalFilename"/>. Never returns null.</returns>
        </member>
        <member name="T:Amber.IO.TextProviderShim">
            <summary>
            A simple <see cref="T:Amber.IO.ITextProvider"/> that passes through all implementing methods to the given delegates.
            </summary>
        </member>
        <member name="T:Amber.IO.TextProviderShim.TakeCharAction">
            <summary>
            Action to be invoked via a call to <see cref="M:Amber.IO.ITextProvider.TakeChar"/>.
            </summary>
            <returns>The next char in the implementing stream or sequence.</returns>
        </member>
        <member name="T:Amber.IO.TextProviderShim.TakeLineAction">
            <summary>
            Action to be invoked via a call to <see cref="M:Amber.IO.ITextProvider.TakeLine"/>.
            </summary>
            <returns>The next line in the implementing stream or sequence.</returns>
        </member>
        <member name="T:Amber.IO.TextProviderShim.TakeTextAction">
            <summary>
            Action to be invoked via a call to <see cref="M:Amber.IO.ITextProvider.TakeText(System.Char[],System.Int32,System.Int32)"/>.
            </summary>
            <param name="target">The target array.</param>
            <param name="startIndex">The index of the first character to be overwritten with the new data.</param>
            <param name="max">The maximum number of characters to write.</param>
            <returns>The actual number of characters written.</returns>
        </member>
        <member name="T:Amber.IO.TextProviderShim.HandleDisposeAction">
            <summary>
            Action to be invoked via a call to <see cref="M:System.IDisposable.Dispose"/>.
            </summary>
        </member>
        <member name="M:Amber.IO.TextProviderShim.#ctor(Amber.IO.TextProviderShim.TakeCharAction,Amber.IO.TextProviderShim.TakeLineAction,Amber.IO.TextProviderShim.TakeTextAction,Amber.IO.TextProviderShim.HandleDisposeAction)">
            <summary>
            Creates a new TextProviderShim with the given actions to be invoked for various calls to the <see cref="T:Amber.IO.ITextProvider"/>
            interface.
            </summary>
            <param name="takeCharAction">The action to be invoked when <see cref="M:Amber.IO.ITextReceiver.HandleText(System.String)"/> is called.
            Must not be null.</param>
            <param name="takeLineAction">The action to be invoked when <see cref="M:Amber.IO.ITextReceiver.HandleLine(System.String)"/> is called.
            Must not be null.</param>
            <param name="takeTextAction">The action to be invoked when <see cref="M:Amber.IO.ITextReceiver.HandleText(System.Char[],System.Int32,System.Int32)"/> is called.
            Must not be null.</param>
            <param name="handleDisposeAction">The action to be invoked when <see cref="M:System.IDisposable.Dispose"/> is called.
            Must not be null.</param>
        </member>
        <member name="M:Amber.IO.TextProviderShim.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Amber.IO.TextProviderShim.TakeChar">
            <inheritdoc />
        </member>
        <member name="M:Amber.IO.TextProviderShim.TakeLine">
            <inheritdoc />
        </member>
        <member name="M:Amber.IO.TextProviderShim.TakeText(System.Char[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Amber.IO.TextReceiverShim">
            <summary>
            A simple <see cref="T:Amber.IO.ITextReceiver"/> that passes through all implementing methods to the given delegates.
            </summary>
        </member>
        <member name="T:Amber.IO.TextReceiverShim.HandleTextAction">
            <summary>
            Action to be invoked via a call to <see cref="M:Amber.IO.ITextReceiver.HandleText(System.String)"/>.
            </summary>
            <param name="data">The text to handle.</param>
        </member>
        <member name="T:Amber.IO.TextReceiverShim.HandleLineAction">
            <summary>
            Action to be invoked via a call to <see cref="M:Amber.IO.ITextReceiver.HandleLine(System.String)"/>.
            </summary>
            <param name="data">The text to handle.</param>
        </member>
        <member name="T:Amber.IO.TextReceiverShim.HandleCharArrayAction">
            <summary>
            Action to be invoked via a call to <see cref="M:Amber.IO.ITextReceiver.HandleText(System.Char[],System.Int32,System.Int32)"/>.
            </summary>
            <param name="data">The text to handle.</param>
            <param name="startIndex">The index of the first character in <paramref name="data"/> to start from.</param>
            <param name="count">The number of characters in <paramref name="data"/> to use.</param>
        </member>
        <member name="T:Amber.IO.TextReceiverShim.HandleDisposeAction">
            <summary>
            Action to be invoked via a call to <see cref="M:System.IDisposable.Dispose"/>.
            </summary>
        </member>
        <member name="M:Amber.IO.TextReceiverShim.#ctor(Amber.IO.TextReceiverShim.HandleTextAction,Amber.IO.TextReceiverShim.HandleLineAction,Amber.IO.TextReceiverShim.HandleCharArrayAction,Amber.IO.TextReceiverShim.HandleDisposeAction)">
            <summary>
            Creates a new TextReceiverShim with the given actions to be invoked for various calls to the <see cref="T:Amber.IO.ITextReceiver"/>
            interface.
            </summary>
            <param name="handleTextAction">The action to be invoked when <see cref="M:Amber.IO.ITextProvider.TakeChar"/> is called.
            Must not be null.</param>
            <param name="handleLineAction">The action to be invoked when <see cref="M:Amber.IO.ITextProvider.TakeLine"/> is called.
            Must not be null.</param>
            <param name="handleCharArrayAction">The action to be invoked when <see cref="M:Amber.IO.ITextProvider.TakeText(System.Char[],System.Int32,System.Int32)"/> is called.
            Must not be null.</param>
            <param name="handleDisposeAction">The action to be invoked when <see cref="M:System.IDisposable.Dispose"/> is called.
            Must not be null.</param>
        </member>
        <member name="M:Amber.IO.TextReceiverShim.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Amber.IO.TextReceiverShim.HandleText(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Amber.IO.TextReceiverShim.HandleLine(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Amber.IO.TextReceiverShim.HandleText(System.Char[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Amber.IO.TextReceiverStreamReaderShim">
            <summary>
            Implements the given <see cref="T:System.IO.StreamReader"/> as an <see cref="T:Amber.IO.ITextProvider"/>.
            </summary>
        </member>
        <member name="M:Amber.IO.TextReceiverStreamReaderShim.#ctor(System.IO.StreamReader)">
            <summary>
            Create a new TextReceiverStreamReaderShim.
            </summary>
            <param name="streamReader">The stream reader to delegate to. Must not be null.</param>
        </member>
        <member name="M:Amber.IO.TextReceiverStreamReaderShim.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Amber.IO.TextReceiverStreamReaderShim.TakeChar">
            <inheritdoc />
        </member>
        <member name="M:Amber.IO.TextReceiverStreamReaderShim.TakeLine">
            <inheritdoc />
        </member>
        <member name="M:Amber.IO.TextReceiverStreamReaderShim.TakeText(System.Char[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Amber.IO.TextReceiverStreamReaderShim.op_Implicit(System.IO.StreamReader)~Amber.IO.TextReceiverStreamReaderShim">
            <summary>
            Implicit conversion to create an <see cref="T:Amber.IO.ITextProvider"/> from a <see cref="T:System.IO.StreamReader"/>.
            </summary>
            <param name="operand">The stream reader.</param>
            <returns>A new <see cref="T:Amber.IO.TextReceiverStreamReaderShim"/>.</returns>
        </member>
        <member name="T:Amber.IO.TextReceiverStreamWriterShim">
            <summary>
            Implements the given <see cref="T:System.IO.StreamWriter"/> as an <see cref="T:Amber.IO.ITextReceiver"/>.
            </summary>
        </member>
        <member name="M:Amber.IO.TextReceiverStreamWriterShim.#ctor(System.IO.StreamWriter)">
            <summary>
            Create a new TextReceiverStreamWriterShim.
            </summary>
            <param name="streamWriter">The stream writer to delegate to. Must not be null.</param>
        </member>
        <member name="M:Amber.IO.TextReceiverStreamWriterShim.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Amber.IO.TextReceiverStreamWriterShim.HandleText(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Amber.IO.TextReceiverStreamWriterShim.HandleLine(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Amber.IO.TextReceiverStreamWriterShim.HandleText(System.Char[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Amber.IO.TextReceiverStreamWriterShim.op_Implicit(System.IO.StreamWriter)~Amber.IO.TextReceiverStreamWriterShim">
            <summary>
            Implicit conversion to create an <see cref="T:Amber.IO.ITextReceiver"/> from a <see cref="T:System.IO.StreamWriter"/>.
            </summary>
            <param name="operand">The stream writer.</param>
            <returns>A new <see cref="T:Amber.IO.TextReceiverStreamWriterShim"/>.</returns>
        </member>
        <member name="T:Amber.Testing.Integration.IntegrationTestTearDownStrategyAttribute">
            <summary>
            Tell the integration test runner under what conditions to run the <see cref="M:Amber.Testing.Integration.IIntegrationTest.TearDown"/> for
            an <see cref="T:Amber.Testing.Integration.IIntegrationTest"/>.
            </summary>
        </member>
        <member name="P:Amber.Testing.Integration.IntegrationTestTearDownStrategyAttribute.RunIfSetUpTimesOut">
            <summary>
            Whether or not to run the <see cref="M:Amber.Testing.Integration.IIntegrationTest.TearDown"/> if the test fails due to a timeout in the
            <see cref="M:Amber.Testing.Integration.IIntegrationTest.SetUp"/> method. Defaults to <c>false</c>.
            </summary>
        </member>
        <member name="P:Amber.Testing.Integration.IntegrationTestTearDownStrategyAttribute.RunIfSetUpThrowsException">
            <summary>
            Whether or not to run the <see cref="M:Amber.Testing.Integration.IIntegrationTest.TearDown"/> if the test fails due to an exception being thrown in the
            <see cref="M:Amber.Testing.Integration.IIntegrationTest.SetUp"/> method. Defaults to <c>false</c>.
            </summary>
        </member>
        <member name="P:Amber.Testing.Integration.IntegrationTestTearDownStrategyAttribute.RunIfDoTestTimesOut">
            <summary>
            Whether or not to run the <see cref="M:Amber.Testing.Integration.IIntegrationTest.TearDown"/> if the test fails due to a timeout in the
            <see cref="M:Amber.Testing.Integration.IIntegrationTest.DoTest"/> method. Defaults to <c>true</c>.
            </summary>
        </member>
        <member name="P:Amber.Testing.Integration.IntegrationTestTearDownStrategyAttribute.RunIfDoTestThrowsException">
            <summary>
            Whether or not to run the <see cref="M:Amber.Testing.Integration.IIntegrationTest.TearDown"/> if the test fails due to an exception being thrown in the
            <see cref="M:Amber.Testing.Integration.IIntegrationTest.DoTest"/> method. Defaults to <c>true</c>.
            </summary>
        </member>
        <member name="T:Amber.Testing.Integration.IntegrationTestIgnoreAttribute">
            <summary>
            Tell the integration test runner to ignore an <see cref="T:Amber.Testing.Integration.IIntegrationTest"/>. The test will not be run unless explicitly invoked
            via a call to <see cref="M:Amber.Testing.Integration.IntegrationTestRunner.RunSpecificTest(Amber.Testing.Integration.IIntegrationTest)"/>.
            </summary>
        </member>
        <member name="F:Amber.Testing.Integration.IntegrationTestIgnoreAttribute.Reason">
            <summary>
            The reason this test is ignored.
            </summary>
        </member>
        <member name="M:Amber.Testing.Integration.IntegrationTestIgnoreAttribute.#ctor(System.String)">
            <summary>
            Create a new ignore-test attribute.
            </summary>
            <param name="reason">The reason this test is ignored. Must not be null.</param>
        </member>
        <member name="T:Amber.Testing.Integration.IntegrationTestingAssertions">
            <summary>
            Class containing assertion helper methods for integration tests.
            </summary>
        </member>
        <member name="M:Amber.Testing.Integration.IntegrationTestingAssertions.Assert(System.Boolean)">
            <summary>
            Assert that the given expression evaluates to <c>true</c>. If <c>false</c>, an <see cref="T:Amber.Testing.Integration.IntegrationTestException"/>
            will be thrown.
            </summary>
            <param name="condition">The expression to evaluate.</param>
        </member>
        <member name="M:Amber.Testing.Integration.IntegrationTestingAssertions.Assert(System.Boolean,System.String,System.String)">
            <summary>
            Assert that the given expression evaluates to <c>true</c>. If <c>false</c>, an <see cref="T:Amber.Testing.Integration.IntegrationTestException"/>
            will be thrown.
            </summary>
            <param name="condition">The expression to evaluate.</param>
            <param name="operationUnderTest">The operation under test (e.g. "Downloading data from remote host").</param>
            <param name="assertionDescription">The assertion being tested by this call (e.g. "Download result returned successful status code").</param>
        </member>
        <member name="M:Amber.Testing.Integration.IntegrationTestingAssertions.Assert(System.Func{System.Boolean})">
            <summary>
            Assert that the result of an invocation of the given <paramref name="predicate"/> evaluates to <c>true</c>.
            </summary>
            <param name="predicate">A function that will be invoked and tested for a return value of <c>true</c>.</param>
        </member>
        <member name="M:Amber.Testing.Integration.IntegrationTestingAssertions.Assert(System.Func{System.Boolean},System.String,System.String)">
            <summary>
            Assert that the result of an invocation of the given <paramref name="predicate"/> evaluates to <c>true</c>.
            </summary>
            <param name="predicate">A function that will be invoked and tested for a return value of <c>true</c>.</param>
            <param name="operationUnderTest">The operation under test (e.g. "Downloading data from remote host").</param>
            <param name="assertionDescription">The assertion being tested by this call (e.g. "Download result returned successful status code").</param>
        </member>
        <member name="T:Amber.Testing.Integration.BambooIntegrationTestRunner">
            <summary>
            A specialized <see cref="T:Amber.Testing.Integration.IntegrationTestRunner"/> that outputs errors to <see cref="P:System.Console.Error"/> (which in turn makes
            those lines be highlighted in red on the Bamboo log viewer).
            </summary>
        </member>
        <member name="M:Amber.Testing.Integration.BambooIntegrationTestRunner.Initialize(System.Reflection.Assembly[])">
            <inheritdoc />
        </member>
        <member name="M:Amber.Testing.Integration.BambooIntegrationTestRunner.Shutdown">
            <inheritdoc />
        </member>
        <member name="T:Amber.Testing.Integration.IntegrationTestRunner">
            <summary>
            Class that handles the automatic discovery and execution of <see cref="T:Amber.Testing.Integration.IIntegrationTest"/>s.
            </summary>
        </member>
        <member name="F:Amber.Testing.Integration.IntegrationTestRunner.DefaultTestTimeout">
            <summary>
            The default time a test can run for before being considered 'timed out' and failed. Tests can override this value
            by specifying a <see cref="T:Amber.Testing.Integration.IntegrationTestTimeoutAttribute">IntegrationTestTimeout</see>.
            </summary>
        </member>
        <member name="F:Amber.Testing.Integration.IntegrationTestRunner.DefaultMinTearDownTime">
            <summary>
            The minimum amount of time allocated to a tear down.
            </summary>
        </member>
        <member name="P:Amber.Testing.Integration.IntegrationTestRunner.IsInitialized">
            <summary>
            Whether or not this runner has already been initialized.
            </summary>
        </member>
        <member name="M:Amber.Testing.Integration.IntegrationTestRunner.Initialize(System.Reflection.Assembly[])">
            <summary>
            Initialize this runner; providing all the assemblies that it should search for integration tests in.
            This function must be called exactly once before <see cref="M:Amber.Testing.Integration.IntegrationTestRunner.RunAllTests"/>.
            </summary>
            <param name="targetAssemblies"></param>
        </member>
        <member name="M:Amber.Testing.Integration.IntegrationTestRunner.RunSpecificTest(Amber.Testing.Integration.IIntegrationTest)">
            <summary>
            Run the specific integration test. The given test does not need to be from the target assemblies provided to
            <see cref="M:Amber.Testing.Integration.IntegrationTestRunner.Initialize(System.Reflection.Assembly[])"/>; but the runner must still have been initialized.
            </summary>
            <param name="testInstance">The test to run. Must not be null.</param>
        </member>
        <member name="M:Amber.Testing.Integration.IntegrationTestRunner.RunAllTests">
            <summary>
            Run all tests that were discovered in the given target assemblies (passed in through <see cref="M:Amber.Testing.Integration.IntegrationTestRunner.Initialize(System.Reflection.Assembly[])"/>).
            </summary>
        </member>
        <member name="M:Amber.Testing.Integration.IntegrationTestRunner.Shutdown">
            <summary>
            Shut down this runner. The value returned from this function represents a return code indicating the overall success
            or failure of the suite of tests.
            </summary>
            <returns>By default, the function returns <c>0</c> when all tests passed; or if at least one test
            failed, the number of tests that failed.</returns>
        </member>
        <member name="M:Amber.Testing.Integration.IntegrationTestRunner.SetUpTest(Amber.Testing.Integration.IIntegrationTest)">
            <summary>
            Called by this runner when it's time to run the <see cref="M:Amber.Testing.Integration.IIntegrationTest.SetUp"/> method on the
            given <paramref name="test"/>. When overriding this method, child classes should ideally call
            the base implementation at some point if the <see cref="M:Amber.Testing.Integration.IIntegrationTest.SetUp"/> method should be run.
            </summary>
            <param name="test">The integration test to be set up. Will never be null.</param>
        </member>
        <member name="M:Amber.Testing.Integration.IntegrationTestRunner.DoTest(Amber.Testing.Integration.IIntegrationTest)">
            <summary>
            Called by this runner when it's time to run the <see cref="M:Amber.Testing.Integration.IIntegrationTest.DoTest"/> method on the
            given <paramref name="test"/>. When overriding this method, child classes should ideally call
            the base implementation at some point if the <see cref="M:Amber.Testing.Integration.IIntegrationTest.DoTest"/> method should be run.
            </summary>
            <param name="test">The integration test to be tested. Will never be null.</param>
        </member>
        <member name="M:Amber.Testing.Integration.IntegrationTestRunner.TearDownTest(Amber.Testing.Integration.IIntegrationTest)">
            <summary>
            Called by this runner when it's time to run the <see cref="M:Amber.Testing.Integration.IIntegrationTest.TearDown"/> method on the
            given <paramref name="test"/>. When overriding this method, child classes should ideally call
            the base implementation at some point if the <see cref="M:Amber.Testing.Integration.IIntegrationTest.TearDown"/> method should be run.
            </summary>
            <param name="test">The integration test to be torn down. Will never be null.</param>
        </member>
        <member name="T:Amber.Testing.Integration.IntegrationTestTimeoutAttribute">
            <summary>
            Set the timeout (maximum running length) for an <see cref="T:Amber.Testing.Integration.IIntegrationTest"/>.
            </summary>
        </member>
        <member name="F:Amber.Testing.Integration.IntegrationTestTimeoutAttribute.Timeout">
            <summary>
            The maximum running time for the target test, including time taken by <see cref="M:Amber.Testing.Integration.IIntegrationTest.SetUp"/>
            and <see cref="M:Amber.Testing.Integration.IIntegrationTest.TearDown"/> as well as <see cref="M:Amber.Testing.Integration.IIntegrationTest.DoTest"/>.
            </summary>
        </member>
        <member name="M:Amber.Testing.Integration.IntegrationTestTimeoutAttribute.#ctor(System.UInt64)">
            <summary>
            Create a new integration test timeout attribute.
            </summary>
            <param name="timeoutMilliseconds">The maximum running time for the target test in milliseconds,
            including time taken by <see cref="M:Amber.Testing.Integration.IIntegrationTest.SetUp"/> and <see cref="M:Amber.Testing.Integration.IIntegrationTest.TearDown"/> as well as
            <see cref="M:Amber.Testing.Integration.IIntegrationTest.DoTest"/>.</param>
        </member>
        <member name="T:Amber.Testing.Integration.IIntegrationTest">
            <summary>
            Represents an integration test that can be automatically run via an <see cref="T:Amber.Testing.Integration.IntegrationTestRunner"/>.
            </summary>
            <remarks>
            <para>By default, tests are considered failed if they run for longer than the <see cref="F:Amber.Testing.Integration.IntegrationTestRunner.DefaultTestTimeout"/>
            (including the time taken by <see cref="M:Amber.Testing.Integration.IIntegrationTest.SetUp"/> and <see cref="M:Amber.Testing.Integration.IIntegrationTest.TearDown"/> as well as <see cref="M:Amber.Testing.Integration.IIntegrationTest.DoTest"/>). Integration tests
            can override the default timeout by supplying an <see cref="T:Amber.Testing.Integration.IntegrationTestTimeoutAttribute"/>.</para>
            <para>All tests are run in a blank directory that is cleared (all items deleted) after the test finishes.</para>
            </remarks>
        </member>
        <member name="P:Amber.Testing.Integration.IIntegrationTest.Name">
            <summary>
            The name of this test (used in logging).
            </summary>
        </member>
        <member name="M:Amber.Testing.Integration.IIntegrationTest.SetUp">
            <summary>
            Set up this test. This function does not need to do anything if there is no set up required. Called before anything else.
            If this function throws any exceptions, the test will be considered failed and neither 
            <see cref="M:Amber.Testing.Integration.IIntegrationTest.DoTest"/> nor <see cref="M:Amber.Testing.Integration.IIntegrationTest.TearDown"/> will be run.
            </summary>
        </member>
        <member name="M:Amber.Testing.Integration.IIntegrationTest.DoTest">
            <summary>
            Run this test. This function is called after a successful invocation of <see cref="M:Amber.Testing.Integration.IIntegrationTest.SetUp"/>.
            If this function successfully returns without throwing any exceptions, the test will be considered a success.
            Tests should ideally throw <see cref="T:Amber.Testing.Integration.IntegrationTestException"/>s to indicate failures (though any exception type will do).
            </summary>
        </member>
        <member name="M:Amber.Testing.Integration.IIntegrationTest.TearDown">
            <summary>
            Clean up any resources used by this test. This function does not need to do anything if there is no tear down required.
            Called only after a successful invocation of <see cref="M:Amber.Testing.Integration.IIntegrationTest.SetUp"/>, but still called even if 
            <see cref="M:Amber.Testing.Integration.IIntegrationTest.DoTest"/> fails. If this function throws any exceptions, the test will be considered failed.
            </summary>
        </member>
        <member name="T:Amber.Testing.Integration.IntegrationTestException">
            <summary>
            An exception class that represents a failed <see cref="T:Amber.Testing.Integration.IIntegrationTest"/>.
            </summary>
        </member>
        <member name="F:Amber.Testing.Integration.IntegrationTestException.FailedOperation">
            <summary>
            The test operation that failed. Will never be null.
            </summary>
        </member>
        <member name="F:Amber.Testing.Integration.IntegrationTestException.FailureDescription">
            <summary>
            A string describing how the <see cref="F:Amber.Testing.Integration.IntegrationTestException.FailedOperation"/> failed. Will never be null.
            </summary>
        </member>
        <member name="M:Amber.Testing.Integration.IntegrationTestException.#ctor(System.String,System.String)">
            <summary>
            Create a new IntegrationTestException.
            </summary>
            <param name="failedOperation">The test operation that failed (for example, "Downloading data from remote host").</param>
            <param name="failureDescription">A string describing how the <paramref name="failedOperation"/> failed
            (for example, "Remote host returned 405 error").</param>
        </member>
        <member name="M:Amber.Testing.Integration.IntegrationTestException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Create a new IntegrationTestException.
            </summary>
            <param name="failedOperation">The test operation that failed (for example, "Downloading data from remote host").</param>
            <param name="failureDescription">A string describing how the <paramref name="failedOperation"/> failed
            (for example, "Remote host returned 405 error").</param>
            <param name="associatedException">An exception object associated with this failure.</param>
        </member>
        <member name="T:Amber.Threading.AsyncIncrementableGuardVar">
            <summary>
            Represents a <see cref="T:System.Int64"/> that can only have its value increased. Threads can wait for the value to reach a target
            synchronously or via task-based or async/await paradigms.
            </summary>
        </member>
        <member name="P:Amber.Threading.AsyncIncrementableGuardVar.CurrentValue">
            <summary>
            The current value of the variable. Be careful when using this property for anything more than logging/simple checks: Its
            value is only correct exactly at the time of the call; it may change immediately after.
            <para>
            Setting the value via this property is identical to calling <see cref="M:Amber.Threading.AsyncIncrementableGuardVar.SetValue(System.Int64)"/>.
            </para>
            </summary>
        </member>
        <member name="M:Amber.Threading.AsyncIncrementableGuardVar.#ctor">
            <summary>
            Create a new guard variable whose initial value is <c>0L</c>.
            </summary>
        </member>
        <member name="M:Amber.Threading.AsyncIncrementableGuardVar.#ctor(System.Int64)">
            <summary>
            Create a new guard variable whose initial value is set according to the given <paramref name="initialValue"/> parameter.
            </summary>
            <param name="initialValue">The initial value for this variable. Can be any possible <see cref="T:System.Int64"/>.</param>
        </member>
        <member name="M:Amber.Threading.AsyncIncrementableGuardVar.WaitForValueToReachTarget(System.Int64)">
            <summary>
            Synchronously wait for the <see cref="P:Amber.Threading.AsyncIncrementableGuardVar.CurrentValue"/> to be greater than or equal to <paramref name="target"/>.
            If <see cref="P:Amber.Threading.AsyncIncrementableGuardVar.CurrentValue"/> is already greater than or equal to <paramref name="target"/>, this method returns
            immediately. Otherwise, this method blocks until the target is reached.
            </summary>
            <param name="target">The target value to wait for.</param>
        </member>
        <member name="M:Amber.Threading.AsyncIncrementableGuardVar.WaitForValueToReachTarget(System.Int64,System.TimeSpan)">
            <summary>
            Synchronously wait for the <see cref="P:Amber.Threading.AsyncIncrementableGuardVar.CurrentValue"/> to be greater than or equal to <paramref name="target"/>.
            If <see cref="P:Amber.Threading.AsyncIncrementableGuardVar.CurrentValue"/> is already greater than or equal to <paramref name="target"/>, this method returns
            immediately. Otherwise, this method blocks until either the target is reached or the given <paramref name="timeout"/>
            expires.
            </summary>
            <param name="target">The target value to wait for.</param>
            <param name="timeout">The maximum amount of time to wait for the target value to be reached. If this parameter
            is less than or equal to <see cref="F:System.TimeSpan.Zero"/>, then no timeout will be applied.</param>
            <returns><c>True</c> if the target was reached before the timeout expired; or <c>false</c> if the method returned
            due to the timeout.</returns>
        </member>
        <member name="M:Amber.Threading.AsyncIncrementableGuardVar.WaitForValueToReachTargetAsync(System.Int64)">
            <summary>
            Asynchronously wait for the <see cref="P:Amber.Threading.AsyncIncrementableGuardVar.CurrentValue"/> to be greater than or equal to <paramref name="target"/>.
            If <see cref="P:Amber.Threading.AsyncIncrementableGuardVar.CurrentValue"/> is already greater than or equal to <paramref name="target"/>, this method returns
            a completed task immediately. Otherwise, this method returns a task that completes once the <paramref name="target"/>
            is met.
            </summary>
            <param name="target">The target value to wait for.</param>
        </member>
        <member name="M:Amber.Threading.AsyncIncrementableGuardVar.WaitForValueToReachTargetAsync(System.Int64,System.TimeSpan)">
            <summary>
            Asynchronously wait for the <see cref="P:Amber.Threading.AsyncIncrementableGuardVar.CurrentValue"/> to be greater than or equal to <paramref name="target"/>.
            If <see cref="P:Amber.Threading.AsyncIncrementableGuardVar.CurrentValue"/> is already greater than or equal to <paramref name="target"/>, this method returns
            a completed task immediately. Otherwise, this method returns a task that completes either when
            the given <paramref name="target"/> is met, or when the given <paramref name="timeout"/> expires (whichever comes first).
            expires.
            </summary>
            <param name="target">The target value to wait for.</param>
            <param name="timeout">The maximum amount of time to wait for the target value to be reached. If this parameter
            is less than or equal to <see cref="F:System.TimeSpan.Zero"/>, then no timeout will be applied.</param>
            <returns>A task whose completion indicates that either the target was met or the timeout expired. The
            <see cref="P:System.Threading.Tasks.Task`1.Result"/> of the completed task will be <c>True</c> if the target was reached before the timeout expired;
            or <c>false</c> if the task completed due to the timeout.</returns>
        </member>
        <member name="M:Amber.Threading.AsyncIncrementableGuardVar.IncrementValue">
            <summary>
            Increment the <see cref="P:Amber.Threading.AsyncIncrementableGuardVar.CurrentValue"/> by one. Equivalent to calling <see cref="M:Amber.Threading.AsyncIncrementableGuardVar.IncrementValue(System.Int64)"/> with parameter
            <c>1L</c>.
            </summary>
        </member>
        <member name="M:Amber.Threading.AsyncIncrementableGuardVar.IncrementValue(System.Int64)">
            <summary>
            Increment the <see cref="P:Amber.Threading.AsyncIncrementableGuardVar.CurrentValue"/> by the given <paramref name="amount"/>. Any threads/tasks waiting on a target value
            will be woken/completed if the new value matches or exceeds that target.
            </summary>
            <param name="amount">The amount to increment by. For example, if the <see cref="P:Amber.Threading.AsyncIncrementableGuardVar.CurrentValue"/> is <c>30L</c>
            and this parameter is <c>10L</c>, the new <see cref="P:Amber.Threading.AsyncIncrementableGuardVar.CurrentValue"/> will be <c>40L</c>.</param>
            <exception cref="T:System.OverflowException">Thrown if adding the given <paramref name="amount"/> would cause the
            <see cref="P:Amber.Threading.AsyncIncrementableGuardVar.CurrentValue"/> to overflow.</exception>
        </member>
        <member name="M:Amber.Threading.AsyncIncrementableGuardVar.SetValue(System.Int64)">
            <summary>
            Set the <see cref="P:Amber.Threading.AsyncIncrementableGuardVar.CurrentValue"/> to the given new <paramref name="value"/>. Any threads/tasks waiting on a target value
            will be woken/completed if the new value matches or exceeds that target.
            <para>
            Great care must be taken when using this method. Attempting to set a value lower than or equal to the current value will result
            in an <see cref="T:System.InvalidOperationException"/> being thrown in order to prevent race conditions. It is not sufficient to check
            <see cref="P:Amber.Threading.AsyncIncrementableGuardVar.CurrentValue"/> first in a multiple-writer environment, as another thread could set a higher value between the
            check and the call to this method.
            </para>
            <para>
            If it's possible that the new given <paramref name="value"/> may already be exceeded, consider using <see cref="M:Amber.Threading.AsyncIncrementableGuardVar.TrySetValue(System.Int64)"/>
            instead.
            </para>
            </summary>
            <param name="value">The new value to set.</param>
            <exception cref="T:System.InvalidOperationException">Thrown if the given new <paramref name="value"/> is lower than or equal to
            the <see cref="P:Amber.Threading.AsyncIncrementableGuardVar.CurrentValue"/> at the time this method is called.</exception>
        </member>
        <member name="M:Amber.Threading.AsyncIncrementableGuardVar.TrySetValue(System.Int64)">
            <summary>
            Try to set the <see cref="P:Amber.Threading.AsyncIncrementableGuardVar.CurrentValue"/> to the given new <paramref name="value"/>. 
            Any threads/tasks waiting on a target value will be woken/completed if the new value matches or exceeds that target.
            <para>
            Attempting to set a value lower than or equal to the current value will be ignored, and the method will return <c>false</c>.
            This method should be used instead of <see cref="M:Amber.Threading.AsyncIncrementableGuardVar.SetValue(System.Int64)"/> when it is possible that the given new <paramref name="value"/>
            may already have been exceeded.
            </para>
            </summary>
            <param name="value">The new value to set.</param>
            <returns><c>True</c> if the new value was set, or <c>false</c> if the <see cref="P:Amber.Threading.AsyncIncrementableGuardVar.CurrentValue"/> already equals or
            exceeds the new value.</returns>
        </member>
        <member name="T:Amber.Threading.AsyncThreadSignal">
            <summary>
            A simple inter-thread signal (that can be activated an unlimited number of times) that also supports asynchronous
            waiting via tasks. This class allows any number of threads or coroutines to wait for the next signal to be sent via
            <see cref="M:Amber.Threading.AsyncThreadSignal.SendSignal"/>. The signal can be awaited and sent multiple times.
            </summary>
        </member>
        <member name="M:Amber.Threading.AsyncThreadSignal.#ctor">
            <summary>
            Create a new signal. The signal is created ready to be used.
            </summary>
        </member>
        <member name="M:Amber.Threading.AsyncThreadSignal.WaitForSignal">
            <summary>
            Synchronously wait for the next signal from another thread. This method blocks the caller until another thread calls
            <see cref="M:Amber.Threading.AsyncThreadSignal.SendSignal"/>.
            </summary>
        </member>
        <member name="M:Amber.Threading.AsyncThreadSignal.WaitForSignal(System.TimeSpan)">
            <summary>
            Synchronously wait for the next signal from another thread. This method blocks the caller until another thread calls
            <see cref="M:Amber.Threading.AsyncThreadSignal.SendSignal"/> or the given <paramref name="timeout"/> elapses.
            </summary>
            <param name="timeout">The maximum amount of time to wait for the signal to be sent. If this value is less than
            or equal to <see cref="F:System.TimeSpan.Zero"/>, the function will simply wait indefinitely until <see cref="M:Amber.Threading.AsyncThreadSignal.SendSignal"/>
            is called.</param>
            <returns><c>True</c> if the signal was sent before the <paramref name="timeout"/> elapsed; or <c>false</c> if
            the signal was not sent before the <paramref name="timeout"/> elapsed.</returns>
        </member>
        <member name="M:Amber.Threading.AsyncThreadSignal.WaitForSignalAsync">
            <summary>
            Asynchronously wait for the next signal from another thread. This method will not block the calling thead.
            </summary>
            <returns>A task whose completion signifies that <see cref="M:Amber.Threading.AsyncThreadSignal.SendSignal"/> has been called.</returns>
        </member>
        <member name="M:Amber.Threading.AsyncThreadSignal.WaitForSignalAsync(System.TimeSpan)">
            <summary>
            Asynchronously wait for the next signal from another thread. This method will not block the calling thread.
            </summary>
            <param name="timeout">The maximum amount of time to wait for the signal to be sent. If this value is less than
            or equal to <see cref="F:System.TimeSpan.Zero"/>, the returned task will simply wait indefinitely until <see cref="M:Amber.Threading.AsyncThreadSignal.SendSignal"/>
            is called.</param>
            <returns>A task whose completion signifies that either <see cref="M:Amber.Threading.AsyncThreadSignal.SendSignal"/> was called or that the
            <paramref name="timeout"/> elapsed. The <see cref="P:System.Threading.Tasks.Task`1.Result"/> of the returned Task will be <c>true</c>
            if the signal was sent before the <paramref name="timeout"/> elapsed; or <c>false</c> if
            the signal was not sent before the <paramref name="timeout"/> elapsed.</returns>
        </member>
        <member name="M:Amber.Threading.AsyncThreadSignal.SendSignal">
            <summary>
            Send the next signal to all threads and tasks that are currently waiting. All waiting threads and tasks will be released; and
            any subsequent waiters will be queued up until the next time this method is called.
            </summary>
        </member>
        <member name="T:Amber.Threading.ConcurrentObjectPool`1">
            <summary>
            A class that allows pooling of objects of type <typeparamref name="T"/>. Is free-threaded, meaning that items can be
            reserved and freed from any number of threads, and items do not have to be freed on the same thread they were reserved from.
            </summary>
            <typeparam name="T">The type of object this pool contains.</typeparam>
        </member>
        <member name="F:Amber.Threading.ConcurrentObjectPool`1.MaxPoolSize">
            <summary>
            The maximum number of elements that will be retained in this pool. Freed items that are added in excess of this number will
            simply be discarded.
            </summary>
        </member>
        <member name="P:Amber.Threading.ConcurrentObjectPool`1.CurrentPoolSize">
            <summary>
            The number of objects currently held in the pool.
            </summary>
        </member>
        <member name="M:Amber.Threading.ConcurrentObjectPool`1.#ctor(System.Func{`0})">
            <summary>
            Create a new concurrent object pool with the given <paramref name="factoryFunc"/>.
            </summary>
            <param name="factoryFunc">A function that will be called when a request to reserve one or more items is made and the
            pool is empty. This function is expected to return a new item of type <typeparamref name="T"/>. Must not be null.</param>
        </member>
        <member name="M:Amber.Threading.ConcurrentObjectPool`1.#ctor(System.Func{`0},System.Int32)">
            <summary>
            Create a new concurrent object pool with the given <paramref name="factoryFunc"/> and maximum size (useful for capping
            maximum memory usage).
            </summary>
            <param name="factoryFunc">A function that will be called when a request to reserve one or more items is made and the
            pool is empty. This function is expected to return a new item of type <typeparamref name="T"/>. Must not be null.</param>
            <param name="maxPoolSize">The maximum number of items that may be retained by this pool at any one time. If more items
            are freed back to the pool when the max size has already been reached those items will simply be discarded; and will
            be eligible for garbage collection if no other code holds a reference to them. Must not be negative.</param>
        </member>
        <member name="M:Amber.Threading.ConcurrentObjectPool`1.Reserve(System.Int32)">
            <summary>
            Reserve a number of items from this pool (take them out of the pool). The items will not be referenced anywhere
            while reserved, and must be added back when no longer needed with <see cref="M:Amber.Threading.ConcurrentObjectPool`1.Free(System.Collections.Generic.ICollection{`0})"/> or <see cref="M:Amber.Threading.ConcurrentObjectPool`1.FreeOne(`0)"/>.
            </summary>
            <param name="count">The number of items to reserve. Must be >= 0.</param>
            <returns>A list of reserved items. When the requested <paramref name="count"/> is greater than the
            <see cref="P:Amber.Threading.ConcurrentObjectPool`1.CurrentPoolSize"/>, new items will be added to the end of the returned list.</returns>
        </member>
        <member name="M:Amber.Threading.ConcurrentObjectPool`1.ReserveOne">
            <summary>
            Reserve a single item from this pool (take it out of the pool). The item will not be referenced anywhere while
            reserved, and must be added back when no longer needed with <see cref="M:Amber.Threading.ConcurrentObjectPool`1.FreeOne(`0)"/> or <see cref="M:Amber.Threading.ConcurrentObjectPool`1.Free(System.Collections.Generic.ICollection{`0})"/>.
            </summary>
            <returns>A single reserved item. If the pool is currently empty (i.e. <see cref="P:Amber.Threading.ConcurrentObjectPool`1.CurrentPoolSize"/> is 0) a new
            item will be returned instead.</returns>
        </member>
        <member name="M:Amber.Threading.ConcurrentObjectPool`1.Free(System.Collections.Generic.ICollection{`0})">
            <summary>
            Return previously-reserved items back in to this pool. Additionally, this method may be used to insert new items in to
            the pool. The items will immediately be available for reservation unless the <see cref="F:Amber.Threading.ConcurrentObjectPool`1.MaxPoolSize"/> has been reached,
            in which case they will simply be discarded.
            </summary>
            <param name="items">The collection of items to add to this pool. If any item is null or already contained in this pool an
            exception may be thrown. Must not be null.</param>
        </member>
        <member name="M:Amber.Threading.ConcurrentObjectPool`1.FreeOne(`0)">
            <summary>
            Return a previously-reserved item back in to this pool. Additionally, this method may be used to insert a new item in to
            the pool. The item will immediately be available for reservation unless the <see cref="F:Amber.Threading.ConcurrentObjectPool`1.MaxPoolSize"/> has been reached,
            in which case it will simply be discarded.
            </summary>
            <param name="item">The item to add to this pool. If this item is null or already contained in the pool an exception
            may be thrown.</param>
        </member>
        <member name="T:Amber.Threading.ConcurrentOperationRetryHandler`1">
            <summary>
            A free-threaded type that handles the retrying of a given operation for each value in a sequence, with a set number of attempts
            before deference to a failure action.
            </summary>
            <typeparam name="T">The data item type that is processed on each attempt.</typeparam>
        </member>
        <member name="F:Amber.Threading.ConcurrentOperationRetryHandler`1.NumAttemptsMax">
            <summary>
            The maximum number of attempts for each given data item before that item will be redirected to the failure action.
            </summary>
        </member>
        <member name="F:Amber.Threading.ConcurrentOperationRetryHandler`1.RetryDelay">
            <summary>
            The delay between successive retries of actions on failed data items.
            </summary>
        </member>
        <member name="M:Amber.Threading.ConcurrentOperationRetryHandler`1.#ctor(System.Func{`0,System.Boolean},System.Action{`0},System.Int32,System.TimeSpan)">
            <summary>
            Creates a new retry handler.
            </summary>
            <param name="tryAction">The action to attempt on every passed-in item. If this action throws an exception or returns false,
            the action will be considered 'failed' and retried.</param>
            <param name="failAction">The action that will be invoked on every item for whom the <paramref name="tryAction"/>
            failed <paramref name="numAttemptsMax"/> times.</param>
            <param name="numAttemptsMax">The maximum number of attempts for each item. Must be greater than zero.</param>
            <param name="retryDelay">The retry delay between retry attempts. Must be greater than or equal to <see cref="F:System.TimeSpan.Zero"/>.</param>
        </member>
        <member name="M:Amber.Threading.ConcurrentOperationRetryHandler`1.#ctor(System.Func{`0,System.Boolean},System.Action{`0},System.Int32,System.TimeSpan,System.Action{`0,System.Int32},System.Action{`0,System.Int32})">
            <summary>
            Creates a new retry handler.
            </summary>
            <param name="tryAction">The action to attempt on every passed-in item. If this action throws an exception or returns false,
            the action will be considered 'failed' and retried.</param>
            <param name="failAction">The action that will be invoked on every item for whom the <paramref name="tryAction"/>
            failed <paramref name="numAttemptsMax"/> times.</param>
            <param name="numAttemptsMax">The maximum number of attempts for each item. Must be greater than zero.</param>
            <param name="retryDelay">The retry delay between retry attempts. Must be greater than or equal to <see cref="F:System.TimeSpan.Zero"/>.</param>
            <param name="successAction">An action called by this handler when an item succeeds. The item and the number of attempts made
            in total for the item are passed in (always at least 1). This argument may be <c>null</c> if this callback is not required.</param>
            <param name="pendingRetryAction">An action called by this handler when an item fails and is now pending retry.
            The item and the number of attempts made so far are passed in. This action will <i>not</i> be invoked when an item has exhausted
            all attempts; in other words this action will only be called for items who are pending a retry attempt.
            This argument may be <c>null</c> if this callback is not required.</param>
        </member>
        <member name="M:Amber.Threading.ConcurrentOperationRetryHandler`1.#ctor(System.Func{`0,System.Threading.Tasks.Task{System.Boolean}},System.Func{`0,System.Threading.Tasks.Task},System.Int32,System.TimeSpan)">
            <summary>
            Creates a new retry handler.
            </summary>
            <param name="tryAction">The action to attempt on every passed-in item. If this action throws an exception or returns false,
            the action will be considered 'failed' and retried.</param>
            <param name="failAction">The action that will be invoked on every item for whom the <paramref name="tryAction"/>
            failed <paramref name="numAttemptsMax"/> times.</param>
            <param name="numAttemptsMax">The maximum number of attempts for each item. Must be greater than zero.</param>
            <param name="retryDelay">The retry delay between retry attempts. Must be greater than or equal to <see cref="F:System.TimeSpan.Zero"/>.</param>
        </member>
        <member name="M:Amber.Threading.ConcurrentOperationRetryHandler`1.#ctor(System.Func{`0,System.Threading.Tasks.Task{System.Boolean}},System.Func{`0,System.Threading.Tasks.Task},System.Int32,System.TimeSpan,System.Action{`0,System.Int32},System.Action{`0,System.Int32})">
            <summary>
            Creates a new retry handler.
            </summary>
            <param name="tryAction">The action to attempt on every passed-in item. If this action throws an exception or returns false,
            the action will be considered 'failed' and retried.</param>
            <param name="failAction">The action that will be invoked on every item for whom the <paramref name="tryAction"/>
            failed <paramref name="numAttemptsMax"/> times.</param>
            <param name="numAttemptsMax">The maximum number of attempts for each item. Must be greater than zero.</param>
            <param name="retryDelay">The retry delay between retry attempts. Must be greater than or equal to <see cref="F:System.TimeSpan.Zero"/>.</param>
            <param name="successAction">An action called by this handler when an item succeeds. The item and the number of attempts made
            in total for the item are passed in (always at least 1). This argument may be <c>null</c> if this callback is not required.</param>
            <param name="pendingRetryAction">An action called by this handler when an item fails and is now pending retry.
            The item and the number of attempts made so far are passed in. This action will <i>not</i> be invoked when an item has exhausted
            all attempts; in other words this action will only be called for items who are pending a retry attempt.
            This argument may be <c>null</c> if this callback is not required.</param>
        </member>
        <member name="M:Amber.Threading.ConcurrentOperationRetryHandler`1.Push(`0)">
            <summary>
            Pushes a single item in to this retry handler.
            </summary>
            <param name="item">The item.</param>
        </member>
        <member name="M:Amber.Threading.ConcurrentOperationRetryHandler`1.Push(System.Collections.Generic.ICollection{`0})">
            <summary>
            Pushes a collection of items in to this retry handler.
            </summary>
            <param name="items">The collection of items. All will immediately be pushed.</param>
        </member>
        <member name="M:Amber.Threading.ConcurrentOperationRetryHandler`1.PushStream(System.IObservable{`0})">
            <summary>
            Causes this retry handler to subscribe to the given observable. All published items will be pushed to
            this handler.
            </summary>
            <param name="itemStream">The stream of items; each of which will be pushed in to this handler.</param>
        </member>
        <member name="M:Amber.Threading.ConcurrentOperationRetryHandler`1.Dispose">
            <summary>
            Calls <see cref="M:Amber.Threading.ConcurrentOperationRetryHandler`1.DisposeAsync"/> and blocks the calling thread until the task is completed.
            </summary>
        </member>
        <member name="M:Amber.Threading.ConcurrentOperationRetryHandler`1.DisposeAsync">
            <summary>
            Flush all remaining data through the pipeline (with no further retries). This handler will reject any further data
            pushed to it. And data that is waiting to be retried will be redirected to the failure action.
            </summary>
            <returns>A task that is completed once all remaining data has been pushed through the pipeline.</returns>
        </member>
        <member name="T:Amber.Amps">
            <summary>
            Represents a number of Amperes.
            </summary>
        </member>
        <member name="F:Amber.Amps.UnitSymbol">
            <summary>
            The unit symbol for this type (appended to the <see cref="F:Amber.Amps.Count"/> value returned from <see cref="M:Amber.Amps.ToString"/>).
            </summary>
        </member>
        <member name="F:Amber.Amps.Zero">
            <summary>
            Static readonly value representing a <see cref="F:Amber.Amps.Count"/> of <c>0d</c>.
            </summary>
        </member>
        <member name="F:Amber.Amps.One">
            <summary>
            Static readonly value representing a <see cref="F:Amber.Amps.Count"/> of <c>1d</c>.
            </summary>
        </member>
        <member name="F:Amber.Amps.Count">
            <summary>
            The actual number of Amps this instance represents.
            </summary>
        </member>
        <member name="M:Amber.Amps.#ctor(System.Double)">
            <summary>
            Create a new instance whose <see cref="F:Amber.Amps.Count"/> is equal to the parameter <paramref name="count"/>.
            </summary>
            <param name="count">The <see cref="F:Amber.Amps.Count"/> for this instance.</param>
        </member>
        <member name="M:Amber.Amps.Parse(System.String)">
            <summary>
            Parse the given <paramref name="input"/> string that represents a numeric value.
            </summary>
            <param name="input">The input string. Must contain nothing except either a number, or a number followed by the
            <see cref="F:Amber.Amps.UnitSymbol"/> for this type.</param>
            <returns>The parsed input value.</returns>
        </member>
        <member name="M:Amber.Amps.Plus(Amber.Amps)">
            <summary>
            Add the <paramref name="operand"/>'s <see cref="F:Amber.Amps.Count"/> to this instance's <see cref="F:Amber.Amps.Count"/>.
            </summary>
            <param name="operand">The other value to add.</param>
            <returns>A new <see cref="T:Amber.Amps"/> instance that is the sum of this and the <paramref name="operand"/>.</returns>
        </member>
        <member name="M:Amber.Amps.Minus(Amber.Amps)">
            <summary>
            Subtract the <paramref name="operand"/>'s <see cref="F:Amber.Amps.Count"/> from this instance's <see cref="F:Amber.Amps.Count"/>.
            </summary>
            <param name="operand">The value to subtract from this one.</param>
            <returns>A new <see cref="T:Amber.Amps"/> instance that is the difference of <paramref name="operand"/> from this.</returns>
        </member>
        <member name="M:Amber.Amps.MultipliedBy(System.Double)">
            <summary>
            Multiply this instance by the scalar <paramref name="operand"/>.
            </summary>
            <param name="operand">The number to multiply by.</param>
            <returns>A new <see cref="T:Amber.Amps"/> instance that represents this instance's <see cref="F:Amber.Amps.Count"/> multiplied
            by <paramref name="operand"/>.</returns>
        </member>
        <member name="M:Amber.Amps.DividedBy(System.Double)">
            <summary>
            Divide this instance by the scalar <paramref name="operand"/>.
            </summary>
            <param name="operand">The number to divide by.</param>
            <returns>A new <see cref="T:Amber.Amps"/> instance that represents this instance's <see cref="F:Amber.Amps.Count"/> divided
            by <paramref name="operand"/>.</returns>
        </member>
        <member name="M:Amber.Amps.op_Addition(Amber.Amps,Amber.Amps)">
            <summary>
            See <see cref="M:Amber.Amps.Plus(Amber.Amps)"/>.
            </summary>
        </member>
        <member name="M:Amber.Amps.op_Subtraction(Amber.Amps,Amber.Amps)">
            <summary>
            See <see cref="M:Amber.Amps.Minus(Amber.Amps)"/>.
            </summary>
        </member>
        <member name="M:Amber.Amps.op_Multiply(Amber.Amps,System.Double)">
            <summary>
            See <see cref="M:Amber.Amps.MultipliedBy(System.Double)"/>.
            </summary>
        </member>
        <member name="M:Amber.Amps.op_Multiply(System.Double,Amber.Amps)">
            <summary>
            See <see cref="M:Amber.Amps.MultipliedBy(System.Double)"/>.
            </summary>
        </member>
        <member name="M:Amber.Amps.op_Division(Amber.Amps,System.Double)">
            <summary>
            See <see cref="M:Amber.Amps.DividedBy(System.Double)"/>.
            </summary>
        </member>
        <member name="M:Amber.Amps.op_UnaryNegation(Amber.Amps)">
            <summary>
            Reverses this instance's <see cref="F:Amber.Amps.Count"/> (same outcome as multiplying this value by -1).
            </summary>
        </member>
        <member name="M:Amber.Amps.op_Explicit(System.Double)~Amber.Amps">
            <summary>
            Convert the <paramref name="operand"/> to an <see cref="T:Amber.Amps"/> instance with the same <see cref="F:Amber.Amps.Count"/>.
            </summary>
            <param name="operand">The <see cref="F:Amber.Amps.Count"/> for the new instance.</param>
        </member>
        <member name="M:Amber.Amps.op_Explicit(Amber.Amps)~System.Double">
            <summary>
            Convert the <paramref name="operand"/> to a <see cref="T:System.Double"/> that is
            identical to the <paramref name="operand"/>'s <see cref="F:Amber.Amps.Count"/>.
            </summary>
            <param name="operand">The <see cref="T:Amber.Amps"/> instance to convert.</param>
        </member>
        <member name="M:Amber.Amps.ToString">
            <inheritdoc />
        </member>
        <member name="M:Amber.Amps.Equals(Amber.Amps)">
            <inheritdoc />
        </member>
        <member name="M:Amber.Amps.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Amber.Amps.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Amber.Amps.op_Equality(Amber.Amps,Amber.Amps)">
            <summary>
            <see cref="M:Amber.Amps.Equals(Amber.Amps)"/>.
            </summary>
        </member>
        <member name="M:Amber.Amps.op_Inequality(Amber.Amps,Amber.Amps)">
            <summary>
            <see cref="M:Amber.Amps.Equals(Amber.Amps)"/>.
            </summary>
        </member>
        <member name="M:Amber.Amps.CompareTo(Amber.Amps)">
            <inheritdoc />
        </member>
        <member name="M:Amber.Amps.op_GreaterThan(Amber.Amps,Amber.Amps)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.Amps.Count"/>
            is greater than <paramref name="rhs"/>.<see cref="F:Amber.Amps.Count"/>.</returns>
        </member>
        <member name="M:Amber.Amps.op_LessThan(Amber.Amps,Amber.Amps)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.Amps.Count"/>
            is less than <paramref name="rhs"/>.<see cref="F:Amber.Amps.Count"/>.</returns>
        </member>
        <member name="M:Amber.Amps.op_GreaterThanOrEqual(Amber.Amps,Amber.Amps)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.Amps.Count"/>
            is greater than or equal to <paramref name="rhs"/>.<see cref="F:Amber.Amps.Count"/>.</returns>
        </member>
        <member name="M:Amber.Amps.op_LessThanOrEqual(Amber.Amps,Amber.Amps)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.Amps.Count"/>
            is less than or equal to <paramref name="rhs"/>.<see cref="F:Amber.Amps.Count"/>.</returns>
        </member>
        <member name="T:Amber.Centigrade">
            <summary>
            Represents a temperature in Centigrade.
            </summary>
        </member>
        <member name="F:Amber.Centigrade.UnitSymbol">
            <summary>
            The unit symbol for this type (appended to the <see cref="F:Amber.Centigrade.Count"/> value returned from <see cref="M:Amber.Centigrade.ToString"/>).
            </summary>
        </member>
        <member name="F:Amber.Centigrade.Zero">
            <summary>
            Static readonly value representing a <see cref="F:Amber.Centigrade.Count"/> of <c>0d</c>.
            </summary>
        </member>
        <member name="F:Amber.Centigrade.One">
            <summary>
            Static readonly value representing a <see cref="F:Amber.Centigrade.Count"/> of <c>1d</c>.
            </summary>
        </member>
        <member name="F:Amber.Centigrade.Count">
            <summary>
            The actual 'number' of Centigrade this instance represents.
            </summary>
        </member>
        <member name="M:Amber.Centigrade.#ctor(System.Double)">
            <summary>
            Create a new instance whose <see cref="F:Amber.Centigrade.Count"/> is equal to the parameter <paramref name="count"/>.
            </summary>
            <param name="count">The <see cref="F:Amber.Centigrade.Count"/> for this instance.</param>
        </member>
        <member name="M:Amber.Centigrade.Parse(System.String)">
            <summary>
            Parse the given <paramref name="input"/> string that represents a numeric value.
            </summary>
            <param name="input">The input string. Must contain nothing except either a number, or a number followed by the
            <see cref="F:Amber.Centigrade.UnitSymbol"/> for this type.</param>
            <returns>The parsed input value.</returns>
        </member>
        <member name="M:Amber.Centigrade.Plus(Amber.Centigrade)">
            <summary>
            Add the <paramref name="operand"/>'s <see cref="F:Amber.Centigrade.Count"/> to this instance's <see cref="F:Amber.Centigrade.Count"/>.
            </summary>
            <param name="operand">The other value to add.</param>
            <returns>A new <see cref="T:Amber.Centigrade"/> instance that is the sum of this and the <paramref name="operand"/>.</returns>
        </member>
        <member name="M:Amber.Centigrade.Minus(Amber.Centigrade)">
            <summary>
            Subtract the <paramref name="operand"/>'s <see cref="F:Amber.Centigrade.Count"/> from this instance's <see cref="F:Amber.Centigrade.Count"/>.
            </summary>
            <param name="operand">The value to subtract from this one.</param>
            <returns>A new <see cref="T:Amber.Amps"/> instance that is the difference of <paramref name="operand"/> from this.</returns>
        </member>
        <member name="M:Amber.Centigrade.MultipliedBy(System.Double)">
            <summary>
            Multiply this instance by the scalar <paramref name="operand"/>.
            </summary>
            <param name="operand">The number to multiply by.</param>
            <returns>A new <see cref="T:Amber.Centigrade"/> instance that represents this instance's <see cref="F:Amber.Centigrade.Count"/> multiplied
            by <paramref name="operand"/>.</returns>
        </member>
        <member name="M:Amber.Centigrade.DividedBy(System.Double)">
            <summary>
            Divide this instance by the scalar <paramref name="operand"/>.
            </summary>
            <param name="operand">The number to divide by.</param>
            <returns>A new <see cref="T:Amber.Centigrade"/> instance that represents this instance's <see cref="F:Amber.Centigrade.Count"/> divided
            by <paramref name="operand"/>.</returns>
        </member>
        <member name="M:Amber.Centigrade.op_Addition(Amber.Centigrade,Amber.Centigrade)">
            <summary>
            See <see cref="M:Amber.Centigrade.Plus(Amber.Centigrade)"/>.
            </summary>
        </member>
        <member name="M:Amber.Centigrade.op_Subtraction(Amber.Centigrade,Amber.Centigrade)">
            <summary>
            See <see cref="M:Amber.Centigrade.Minus(Amber.Centigrade)"/>.
            </summary>
        </member>
        <member name="M:Amber.Centigrade.op_Multiply(Amber.Centigrade,System.Double)">
            <summary>
            See <see cref="M:Amber.Centigrade.MultipliedBy(System.Double)"/>.
            </summary>
        </member>
        <member name="M:Amber.Centigrade.op_Multiply(System.Double,Amber.Centigrade)">
            <summary>
            See <see cref="M:Amber.Centigrade.MultipliedBy(System.Double)"/>.
            </summary>
        </member>
        <member name="M:Amber.Centigrade.op_Division(Amber.Centigrade,System.Double)">
            <summary>
            See <see cref="M:Amber.Centigrade.DividedBy(System.Double)"/>.
            </summary>
        </member>
        <member name="M:Amber.Centigrade.op_UnaryNegation(Amber.Centigrade)">
            <summary>
            Reverses this instance's <see cref="F:Amber.Centigrade.Count"/> (same outcome as multiplying this value by -1).
            </summary>
        </member>
        <member name="M:Amber.Centigrade.op_Explicit(System.Double)~Amber.Centigrade">
            <summary>
            Convert the <paramref name="operand"/> to a <see cref="T:Amber.Centigrade"/> instance with the same <see cref="F:Amber.Centigrade.Count"/>.
            </summary>
            <param name="operand">The <see cref="F:Amber.Centigrade.Count"/> for the new instance.</param>
        </member>
        <member name="M:Amber.Centigrade.op_Explicit(Amber.Centigrade)~System.Double">
            <summary>
            Convert the <paramref name="operand"/> to a <see cref="T:System.Double"/> that is
            identical to the <paramref name="operand"/>'s <see cref="F:Amber.Centigrade.Count"/>.
            </summary>
            <param name="operand">The <see cref="T:Amber.Centigrade"/> instance to convert.</param>
        </member>
        <member name="M:Amber.Centigrade.ToString">
            <inheritdoc />
        </member>
        <member name="M:Amber.Centigrade.Equals(Amber.Centigrade)">
            <inheritdoc />
        </member>
        <member name="M:Amber.Centigrade.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Amber.Centigrade.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Amber.Centigrade.op_Equality(Amber.Centigrade,Amber.Centigrade)">
            <summary>
            <see cref="M:Amber.Centigrade.Equals(Amber.Centigrade)"/>.
            </summary>
        </member>
        <member name="M:Amber.Centigrade.op_Inequality(Amber.Centigrade,Amber.Centigrade)">
            <summary>
            <see cref="M:Amber.Centigrade.Equals(Amber.Centigrade)"/>.
            </summary>
        </member>
        <member name="M:Amber.Centigrade.CompareTo(Amber.Centigrade)">
            <inheritdoc />
        </member>
        <member name="M:Amber.Centigrade.op_GreaterThan(Amber.Centigrade,Amber.Centigrade)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.Centigrade.Count"/>
            is greater than <paramref name="rhs"/>.<see cref="F:Amber.Centigrade.Count"/>.</returns>
        </member>
        <member name="M:Amber.Centigrade.op_LessThan(Amber.Centigrade,Amber.Centigrade)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.Centigrade.Count"/>
            is less than <paramref name="rhs"/>.<see cref="F:Amber.Centigrade.Count"/>.</returns>
        </member>
        <member name="M:Amber.Centigrade.op_GreaterThanOrEqual(Amber.Centigrade,Amber.Centigrade)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.Centigrade.Count"/>
            is greater than or equal to <paramref name="rhs"/>.<see cref="F:Amber.Centigrade.Count"/>.</returns>
        </member>
        <member name="M:Amber.Centigrade.op_LessThanOrEqual(Amber.Centigrade,Amber.Centigrade)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.Centigrade.Count"/>
            is less than or equal to <paramref name="rhs"/>.<see cref="F:Amber.Centigrade.Count"/>.</returns>
        </member>
        <member name="T:Amber.Joules">
            <summary>
            Represents a number of Joules.
            </summary>
        </member>
        <member name="F:Amber.Joules.UnitSymbol">
            <summary>
            The unit symbol for this type (appended to the <see cref="F:Amber.Joules.Count"/> value returned from <see cref="M:Amber.Joules.ToString"/>).
            </summary>
        </member>
        <member name="F:Amber.Joules.Zero">
            <summary>
            Static readonly value representing a <see cref="F:Amber.Joules.Count"/> of <c>0d</c>.
            </summary>
        </member>
        <member name="F:Amber.Joules.One">
            <summary>
            Static readonly value representing a <see cref="F:Amber.Joules.Count"/> of <c>1d</c>.
            </summary>
        </member>
        <member name="F:Amber.Joules.JoulesInOneKilowattHour">
            <summary>
            Conversion factor from <see cref="T:Amber.Joules"/> to <see cref="T:Amber.KilowattHours"/>.
            </summary>
        </member>
        <member name="F:Amber.Joules.Count">
            <summary>
            The actual number of Joules this instance represents.
            </summary>
        </member>
        <member name="M:Amber.Joules.#ctor(System.Double)">
            <summary>
            Create a new instance whose <see cref="F:Amber.Joules.Count"/> is equal to the parameter <paramref name="count"/>.
            </summary>
            <param name="count">The <see cref="F:Amber.Joules.Count"/> for this instance.</param>
        </member>
        <member name="M:Amber.Joules.Parse(System.String)">
            <summary>
            Parse the given <paramref name="input"/> string that represents a numeric value.
            </summary>
            <param name="input">The input string. Must contain nothing except either a number, or a number followed by the
            <see cref="F:Amber.Joules.UnitSymbol"/> for this type.</param>
            <returns>The parsed input value.</returns>
        </member>
        <member name="M:Amber.Joules.Plus(Amber.Joules)">
            <summary>
            Add the <paramref name="operand"/>'s <see cref="F:Amber.Joules.Count"/> to this instance's <see cref="F:Amber.Joules.Count"/>.
            </summary>
            <param name="operand">The other value to add.</param>
            <returns>A new <see cref="T:Amber.Joules"/> instance that is the sum of this and the <paramref name="operand"/>.</returns>
        </member>
        <member name="M:Amber.Joules.Minus(Amber.Joules)">
            <summary>
            Subtract the <paramref name="operand"/>'s <see cref="F:Amber.Joules.Count"/> from this instance's <see cref="F:Amber.Joules.Count"/>.
            </summary>
            <param name="operand">The value to subtract from this one.</param>
            <returns>A new <see cref="T:Amber.Joules"/> instance that is the difference of <paramref name="operand"/> from this.</returns>
        </member>
        <member name="M:Amber.Joules.MultipliedBy(System.Double)">
            <summary>
            Multiply this instance by the scalar <paramref name="operand"/>.
            </summary>
            <param name="operand">The number to multiply by.</param>
            <returns>A new <see cref="T:Amber.Joules"/> instance that represents this instance's <see cref="F:Amber.Joules.Count"/> multiplied
            by <paramref name="operand"/>.</returns>
        </member>
        <member name="M:Amber.Joules.DividedBy(System.Double)">
            <summary>
            Divide this instance by the scalar <paramref name="operand"/>.
            </summary>
            <param name="operand">The number to divide by.</param>
            <returns>A new <see cref="T:Amber.Joules"/> instance that represents this instance's <see cref="F:Amber.Joules.Count"/> divided
            by <paramref name="operand"/>.</returns>
        </member>
        <member name="M:Amber.Joules.DividedBy(System.TimeSpan)">
            <summary>
            Divide this instance by the given <see cref="T:System.TimeSpan"/>; e.g. determine how much power would be required to
            create this amount of energy in the given time.
            </summary>
            <param name="operand">The <see cref="T:System.TimeSpan"/> to divide by.</param>
            <returns>A new <see cref="T:Amber.Watts"/> that is the result of dividing this <see cref="T:Amber.Joules"/> instance
            by the <see cref="T:System.TimeSpan"/> <paramref name="operand"/>.</returns>
        </member>
        <member name="M:Amber.Joules.DividedBy(Amber.Watts)">
            <summary>
            Divide this instance by the given <see cref="T:Amber.Watts"/>; e.g. determine how much time would be required to
            create this amount of energy from the given power.
            </summary>
            <param name="operand">The <see cref="T:Amber.Watts"/> instance to divide by.</param>
            <returns>A new <see cref="T:System.TimeSpan"/> that is the result of dividing this <see cref="T:Amber.Joules"/> instance
            by the <see cref="T:Amber.Watts"/> <paramref name="operand"/>.</returns>
        </member>
        <member name="M:Amber.Joules.ToKilowattHours">
            <summary>
            Convert this <see cref="T:Amber.Joules"/> instance to the equivalent value in <see cref="T:Amber.KilowattHours"/>.
            </summary>
            <returns>A new <see cref="T:Amber.KilowattHours"/> instance whose <see cref="F:Amber.KilowattHours.Count"/> is set according
            to the <see cref="F:Amber.Joules.JoulesInOneKilowattHour"/> conversion.</returns>
        </member>
        <member name="M:Amber.Joules.CalculateAngularVelocity(System.Double)">
            <summary>
            Calculate the frequency at which a flywheel would spin with the given <paramref name="momentOfInertia"/>
            and this energy represented as kinetic energy.
            </summary>
            <param name="momentOfInertia">The moment of inertia.</param>
            <returns>A new <see cref="T:Amber.Hertz"/> that represents the spin rate of the theoretical flywheel.</returns>
        </member>
        <member name="M:Amber.Joules.op_Addition(Amber.Joules,Amber.Joules)">
            <summary>
            See <see cref="M:Amber.Joules.Plus(Amber.Joules)"/>.
            </summary>
        </member>
        <member name="M:Amber.Joules.op_Subtraction(Amber.Joules,Amber.Joules)">
            <summary>
            See <see cref="M:Amber.Joules.Minus(Amber.Joules)"/>.
            </summary>
        </member>
        <member name="M:Amber.Joules.op_Multiply(Amber.Joules,System.Double)">
            <summary>
            See <see cref="M:Amber.Joules.MultipliedBy(System.Double)"/>.
            </summary>
        </member>
        <member name="M:Amber.Joules.op_Multiply(System.Double,Amber.Joules)">
            <summary>
            See <see cref="M:Amber.Joules.MultipliedBy(System.Double)"/>.
            </summary>
        </member>
        <member name="M:Amber.Joules.op_Division(Amber.Joules,System.Double)">
            <summary>
            See <see cref="M:Amber.Joules.DividedBy(System.Double)"/>.
            </summary>
        </member>
        <member name="M:Amber.Joules.op_UnaryNegation(Amber.Joules)">
            <summary>
            Reverses this instance's <see cref="F:Amber.Joules.Count"/> (same outcome as multiplying this value by -1).
            </summary>
        </member>
        <member name="M:Amber.Joules.op_Division(Amber.Joules,System.TimeSpan)">
            <summary>
            See <see cref="M:Amber.Joules.DividedBy(System.TimeSpan)"/>.
            </summary>
        </member>
        <member name="M:Amber.Joules.op_Division(Amber.Joules,Amber.Watts)">
            <summary>
            See <see cref="M:Amber.Joules.DividedBy(Amber.Watts)"/>.
            </summary>
        </member>
        <member name="M:Amber.Joules.op_Explicit(System.Double)~Amber.Joules">
            <summary>
            Convert the <paramref name="operand"/> to a <see cref="T:Amber.Joules"/> instance with the same <see cref="F:Amber.Joules.Count"/>.
            </summary>
            <param name="operand">The <see cref="F:Amber.Joules.Count"/> for the new instance.</param>
        </member>
        <member name="M:Amber.Joules.op_Explicit(Amber.Joules)~System.Double">
            <summary>
            Convert the <paramref name="operand"/> to a <see cref="T:System.Double"/> that is
            identical to the <paramref name="operand"/>'s <see cref="F:Amber.Joules.Count"/>.
            </summary>
            <param name="operand">The <see cref="T:Amber.Joules"/> instance to convert.</param>
        </member>
        <member name="M:Amber.Joules.op_Implicit(Amber.Joules)~Amber.KilowattHours">
            <summary>,
            See <see cref="M:Amber.Joules.ToKilowattHours"/>.
            </summary>
        </member>
        <member name="M:Amber.Joules.ToString">
            <inheritdoc />
        </member>
        <member name="M:Amber.Joules.Equals(Amber.Joules)">
            <inheritdoc />
        </member>
        <member name="M:Amber.Joules.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Amber.Joules.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Amber.Joules.op_Equality(Amber.Joules,Amber.Joules)">
            <summary>
            <see cref="M:Amber.Joules.Equals(Amber.Joules)"/>.
            </summary>
        </member>
        <member name="M:Amber.Joules.op_Inequality(Amber.Joules,Amber.Joules)">
            <summary>
            <see cref="M:Amber.Joules.Equals(Amber.Joules)"/>.
            </summary>
        </member>
        <member name="M:Amber.Joules.CompareTo(Amber.Joules)">
            <inheritdoc />
        </member>
        <member name="M:Amber.Joules.op_GreaterThan(Amber.Joules,Amber.Joules)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.Joules.Count"/>
            is greater than <paramref name="rhs"/>.<see cref="F:Amber.Joules.Count"/>.</returns>
        </member>
        <member name="M:Amber.Joules.op_LessThan(Amber.Joules,Amber.Joules)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.Joules.Count"/>
            is less than <paramref name="rhs"/>.<see cref="F:Amber.Joules.Count"/>.</returns>
        </member>
        <member name="M:Amber.Joules.op_GreaterThanOrEqual(Amber.Joules,Amber.Joules)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.Joules.Count"/>
            is greater than or equal to <paramref name="rhs"/>.<see cref="F:Amber.Joules.Count"/>.</returns>
        </member>
        <member name="M:Amber.Joules.op_LessThanOrEqual(Amber.Joules,Amber.Joules)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.Joules.Count"/>
            is less than or equal to <paramref name="rhs"/>.<see cref="F:Amber.Joules.Count"/>.</returns>
        </member>
        <member name="T:Amber.KilowattHours">
            <summary>
            Represents a number of KilowattHours.
            </summary>
        </member>
        <member name="F:Amber.KilowattHours.UnitSymbol">
            <summary>
            The unit symbol for this type (appended to the <see cref="F:Amber.KilowattHours.Count"/> value returned from <see cref="M:Amber.KilowattHours.ToString"/>).
            </summary>
        </member>
        <member name="F:Amber.KilowattHours.Zero">
            <summary>
            Static readonly value representing a <see cref="F:Amber.KilowattHours.Count"/> of <c>0d</c>.
            </summary>
        </member>
        <member name="F:Amber.KilowattHours.One">
            <summary>
            Static readonly value representing a <see cref="F:Amber.KilowattHours.Count"/> of <c>1d</c>.
            </summary>
        </member>
        <member name="F:Amber.KilowattHours.Count">
            <summary>
            The actual number of Kilowatt Hours this instance represents.
            </summary>
        </member>
        <member name="M:Amber.KilowattHours.#ctor(System.Double)">
            <summary>
            Create a new instance whose <see cref="F:Amber.KilowattHours.Count"/> is equal to the parameter <paramref name="count"/>.
            </summary>
            <param name="count">The <see cref="F:Amber.KilowattHours.Count"/> for this instance.</param>
        </member>
        <member name="M:Amber.KilowattHours.Parse(System.String)">
            <summary>
            Parse the given <paramref name="input"/> string that represents a numeric value.
            </summary>
            <param name="input">The input string. Must contain nothing except either a number, or a number followed by the
            <see cref="F:Amber.KilowattHours.UnitSymbol"/> for this type.</param>
            <returns>The parsed input value.</returns>
        </member>
        <member name="M:Amber.KilowattHours.Plus(Amber.KilowattHours)">
            <summary>
            Add the <paramref name="operand"/>'s <see cref="F:Amber.KilowattHours.Count"/> to this instance's <see cref="F:Amber.KilowattHours.Count"/>.
            </summary>
            <param name="operand">The other value to add.</param>
            <returns>A new <see cref="T:Amber.KilowattHours"/> instance that is the sum of this and the <paramref name="operand"/>.</returns>
        </member>
        <member name="M:Amber.KilowattHours.Minus(Amber.KilowattHours)">
            <summary>
            Subtract the <paramref name="operand"/>'s <see cref="F:Amber.KilowattHours.Count"/> from this instance's <see cref="F:Amber.KilowattHours.Count"/>.
            </summary>
            <param name="operand">The value to subtract from this one.</param>
            <returns>A new <see cref="T:Amber.KilowattHours"/> instance that is the difference of <paramref name="operand"/> from this.</returns>
        </member>
        <member name="M:Amber.KilowattHours.MultipliedBy(System.Double)">
            <summary>
            Multiply this instance by the scalar <paramref name="operand"/>.
            </summary>
            <param name="operand">The number to multiply by.</param>
            <returns>A new <see cref="T:Amber.KilowattHours"/> instance that represents this instance's <see cref="F:Amber.KilowattHours.Count"/> multiplied
            by <paramref name="operand"/>.</returns>
        </member>
        <member name="M:Amber.KilowattHours.DividedBy(System.Double)">
            <summary>
            Divide this instance by the scalar <paramref name="operand"/>.
            </summary>
            <param name="operand">The number to divide by.</param>
            <returns>A new <see cref="T:Amber.KilowattHours"/> instance that represents this instance's <see cref="F:Amber.KilowattHours.Count"/> divided
            by <paramref name="operand"/>.</returns>
        </member>
        <member name="M:Amber.KilowattHours.DividedBy(System.TimeSpan)">
            <summary>
            Divide this instance by the given <see cref="T:System.TimeSpan"/>; e.g. determine how much power would be required to
            create this amount of energy in the given time.
            </summary>
            <param name="operand">The <see cref="T:System.TimeSpan"/> to divide by.</param>
            <returns>A new <see cref="T:Amber.Watts"/> that is the result of dividing this <see cref="T:Amber.KilowattHours"/> instance
            by the <see cref="T:System.TimeSpan"/> <paramref name="operand"/>.</returns>
        </member>
        <member name="M:Amber.KilowattHours.DividedBy(Amber.Watts)">
            <summary>
            Divide this instance by the given <see cref="T:Amber.Watts"/>; e.g. determine how much time would be required to
            create this amount of energy from the given power.
            </summary>
            <param name="operand">The <see cref="T:Amber.Watts"/> instance to divide by.</param>
            <returns>A new <see cref="T:System.TimeSpan"/> that is the result of dividing this <see cref="T:Amber.KilowattHours"/> instance
            by the <see cref="T:Amber.Watts"/> <paramref name="operand"/>.</returns>
        </member>
        <member name="M:Amber.KilowattHours.ToJoules">
            <summary>
            Convert this <see cref="T:Amber.KilowattHours"/> instance to the equivalent value in <see cref="T:Amber.Joules"/>.
            </summary>
            <returns>A new <see cref="T:Amber.Joules"/> instance whose <see cref="F:Amber.Joules.Count"/> is set according
            to the <see cref="F:Amber.Joules.JoulesInOneKilowattHour"/> conversion.</returns>
        </member>
        <member name="M:Amber.KilowattHours.CalculateAngularVelocity(System.Double)">
            <summary>
            Calculate the frequency at which a flywheel would spin with the given <paramref name="momentOfInertia"/>
            and this energy represented as kinetic energy.
            </summary>
            <param name="momentOfInertia">The moment of inertia.</param>
            <returns>A new <see cref="T:Amber.Hertz"/> that represents the spin rate of the theoretical flywheel.</returns>
        </member>
        <member name="M:Amber.KilowattHours.op_Addition(Amber.KilowattHours,Amber.KilowattHours)">
            <summary>
            See <see cref="M:Amber.KilowattHours.Plus(Amber.KilowattHours)"/>.
            </summary>
        </member>
        <member name="M:Amber.KilowattHours.op_Subtraction(Amber.KilowattHours,Amber.KilowattHours)">
            <summary>
            See <see cref="M:Amber.KilowattHours.Minus(Amber.KilowattHours)"/>.
            </summary>
        </member>
        <member name="M:Amber.KilowattHours.op_Multiply(Amber.KilowattHours,System.Double)">
            <summary>
            See <see cref="M:Amber.KilowattHours.MultipliedBy(System.Double)"/>.
            </summary>
        </member>
        <member name="M:Amber.KilowattHours.op_Multiply(System.Double,Amber.KilowattHours)">
            <summary>
            See <see cref="M:Amber.KilowattHours.MultipliedBy(System.Double)"/>.
            </summary>
        </member>
        <member name="M:Amber.KilowattHours.op_Division(Amber.KilowattHours,System.Double)">
            <summary>
            See <see cref="M:Amber.KilowattHours.DividedBy(System.Double)"/>.
            </summary>
        </member>
        <member name="M:Amber.KilowattHours.op_UnaryNegation(Amber.KilowattHours)">
            <summary>
            Reverses this instance's <see cref="F:Amber.KilowattHours.Count"/> (same outcome as multiplying this value by -1).
            </summary>
        </member>
        <member name="M:Amber.KilowattHours.op_Division(Amber.KilowattHours,System.TimeSpan)">
            <summary>
            See <see cref="M:Amber.KilowattHours.DividedBy(System.TimeSpan)"/>.
            </summary>
        </member>
        <member name="M:Amber.KilowattHours.op_Division(Amber.KilowattHours,Amber.Watts)">
            <summary>
            See <see cref="M:Amber.KilowattHours.DividedBy(Amber.Watts)"/>.
            </summary>
        </member>
        <member name="M:Amber.KilowattHours.op_Explicit(System.Double)~Amber.KilowattHours">
            <summary>
            Convert the <paramref name="operand"/> to a <see cref="T:Amber.KilowattHours"/> instance with the same <see cref="F:Amber.KilowattHours.Count"/>.
            </summary>
            <param name="operand">The <see cref="F:Amber.KilowattHours.Count"/> for the new instance.</param>
        </member>
        <member name="M:Amber.KilowattHours.op_Explicit(Amber.KilowattHours)~System.Double">
            <summary>
            Convert the <paramref name="operand"/> to a <see cref="T:System.Double"/> that is
            identical to the <paramref name="operand"/>'s <see cref="F:Amber.KilowattHours.Count"/>.
            </summary>
            <param name="operand">The <see cref="T:Amber.KilowattHours"/> instance to convert.</param>
        </member>
        <member name="M:Amber.KilowattHours.op_Implicit(Amber.KilowattHours)~Amber.Joules">
            <summary>,
            See <see cref="M:Amber.KilowattHours.ToJoules"/>.
            </summary>
        </member>
        <member name="M:Amber.KilowattHours.ToString">
            <inheritdoc />
        </member>
        <member name="M:Amber.KilowattHours.Equals(Amber.KilowattHours)">
            <inheritdoc />
        </member>
        <member name="M:Amber.KilowattHours.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Amber.KilowattHours.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Amber.KilowattHours.op_Equality(Amber.KilowattHours,Amber.KilowattHours)">
            <summary>
            <see cref="M:Amber.KilowattHours.Equals(Amber.KilowattHours)"/>.
            </summary>
        </member>
        <member name="M:Amber.KilowattHours.op_Inequality(Amber.KilowattHours,Amber.KilowattHours)">
            <summary>
            <see cref="M:Amber.KilowattHours.Equals(Amber.KilowattHours)"/>.
            </summary>
        </member>
        <member name="M:Amber.KilowattHours.CompareTo(Amber.KilowattHours)">
            <inheritdoc />
        </member>
        <member name="M:Amber.KilowattHours.op_GreaterThan(Amber.KilowattHours,Amber.KilowattHours)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.KilowattHours.Count"/>
            is greater than <paramref name="rhs"/>.<see cref="F:Amber.KilowattHours.Count"/>.</returns>
        </member>
        <member name="M:Amber.KilowattHours.op_LessThan(Amber.KilowattHours,Amber.KilowattHours)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.KilowattHours.Count"/>
            is less than <paramref name="rhs"/>.<see cref="F:Amber.KilowattHours.Count"/>.</returns>
        </member>
        <member name="M:Amber.KilowattHours.op_GreaterThanOrEqual(Amber.KilowattHours,Amber.KilowattHours)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.KilowattHours.Count"/>
            is greater than or equal to <paramref name="rhs"/>.<see cref="F:Amber.KilowattHours.Count"/>.</returns>
        </member>
        <member name="M:Amber.KilowattHours.op_LessThanOrEqual(Amber.KilowattHours,Amber.KilowattHours)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.KilowattHours.Count"/>
            is less than or equal to <paramref name="rhs"/>.<see cref="F:Amber.KilowattHours.Count"/>.</returns>
        </member>
        <member name="T:Amber.Primitives.Interfaces.ITableCsvConvertable">
            <summary>
            An object that can be written to a csv file as a row.
            </summary>
        </member>
        <member name="M:Amber.Primitives.Interfaces.ITableCsvConvertable.ToCsvHeader">
            <summary>
            Get the default CSV header for CSV-serialized members of this type.
            </summary>
            <returns>The default CSV header for CSV-serialized members of this type.</returns>
        </member>
        <member name="M:Amber.Primitives.Interfaces.ITableCsvConvertable.ToCsvRow">
            <summary>
            Get this object serialized as a CSV row that matches the header produced by <see cref="M:Amber.Primitives.Interfaces.ITableCsvConvertable.ToCsvHeader"/>;
            </summary>
            <returns></returns>
        </member>
        <member name="T:Amber.BasicLogHandlerConfig">
            <summary>
            A configuration struct containing details about how a <see cref="T:Amber.BasicLogHandler"/> should process incoming log requests.
            </summary>
        </member>
        <member name="F:Amber.BasicLogHandlerConfig.DEFAULT_TIMESTAMP_FORMAT">
            <summary>
            The default format used by the basic log handler when <see cref="F:Amber.BasicLogHandlerConfig.IncludeTimestamps"/> is <c>true</c> and no
            <see cref="F:Amber.BasicLogHandlerConfig.CustomTimestampFormat"/> has been provided.
            </summary>
        </member>
        <member name="F:Amber.BasicLogHandlerConfig.MinimumSeverity">
            <summary>
            Minimum severity level for messages to be processed. Messages that are sent with a lower severity will be ignored by the handler.
            </summary>
        </member>
        <member name="F:Amber.BasicLogHandlerConfig.IncludeTimestamps">
            <summary>
            Whether or not the log handler should append timestamps to the beginning of every message.
            </summary>
        </member>
        <member name="F:Amber.BasicLogHandlerConfig.IncludeFileSource">
            <summary>
            Whether or not the log handler should append the filename of the code that sent a given log message.
            </summary>
        </member>
        <member name="F:Amber.BasicLogHandlerConfig.IncludeMemberSource">
            <summary>
            Whether or not the log handler should append the member name (e.g. function/property name) of the code that
            sent a given log message.
            </summary>
        </member>
        <member name="F:Amber.BasicLogHandlerConfig.MaxDataObjectLines">
            <summary>
            Max number of fields/values that will be enumerated for given data objects. If greater than zero, 
            data objects' members will be enumerated and each one output on a separate line (up to the maximum). 
            If zero, only the summary of data objects will be displayed.
            </summary>
        </member>
        <member name="F:Amber.BasicLogHandlerConfig.ExpandExceptionStackTraces">
            <summary>
            Whether or not the log handler should expand pass-in exception objects to display their associated stack traces.
            If true, stack traces will be shown below the corresponding log message.
            If false, only the summary (messages) of passed-in exceptions will be displayed.
            </summary>
        </member>
        <member name="F:Amber.BasicLogHandlerConfig.CustomTimestampFormat">
            <summary>
            Custom timestamp format for appended timestamps. If this field is <c>null</c>, the default timestamp format
            (<see cref="F:Amber.BasicLogHandlerConfig.DEFAULT_TIMESTAMP_FORMAT"/>) will be used.
            </summary>
        </member>
        <member name="M:Amber.BasicLogHandlerConfig.#ctor(Amber.LoggerSeverity,System.Boolean,System.Boolean,System.Boolean,System.Int32,System.Boolean)">
            <summary>
            Creates a new configuration for a <see cref="T:Amber.BasicLogHandler"/> (such as <see cref="T:Amber.ConsoleWriterLogHandler"/> or
            <see cref="T:Amber.FileWriterLogHandler"/>).
            </summary>
            <param name="minimumSeverity">Minimum severity level for messages to be processed. Messages that are sent with a lower severity will be ignored by the handler.</param>
            <param name="includeTimestamps">Whether or not the log handler should append timestamps to the beginning of every message.</param>
            <param name="includeFileSource">Whether or not the log handler should append 
            the filename of the code that sent a given log message.</param>
            <param name="includeMemberSource">Whether or not the log handler should append the member name 
            (e.g. function/property name) of the code that sent a given log message.</param>
            <param name="maxDataObjectLines">Max number of fields/values that will be enumerated for given data objects. If greater than zero,
            data objects' members will be enumerated and each one output on a separate line (up to the maximum).
            If zero, only the summary of data objects will be displayed.</param>
            <param name="expandExceptionStackTraces">Whether or not the log handler should expand pass-in exception objects to 
            display their associated stack traces. If true, stack traces will be shown below the corresponding log message.
            If false, only the summary (messages) of passed-in exceptions will be displayed.</param>
        </member>
        <member name="M:Amber.BasicLogHandlerConfig.#ctor(Amber.LoggerSeverity,System.Boolean,System.Boolean,System.Boolean,System.Int32,System.Boolean,System.String)">
            <summary>
            Creates a new configuration for a <see cref="T:Amber.BasicLogHandler"/> (such as <see cref="T:Amber.ConsoleWriterLogHandler"/> or
            <see cref="T:Amber.FileWriterLogHandler"/>).
            </summary>
            <param name="minimumSeverity">Minimum severity level for messages to be processed. Messages that are sent with a lower severity will be ignored by the handler.</param>
            <param name="includeTimestamps">Whether or not the log handler should append timestamps to the beginning of every message.</param>
            <param name="includeFileSource">Whether or not the log handler should append 
            the filename of the code that sent a given log message.</param>
            <param name="includeMemberSource">Whether or not the log handler should append the member name 
            (e.g. function/property name) of the code that sent a given log message.</param>
            <param name="maxDataObjectLines">Max number of fields/values that will be enumerated for given data objects. If greater than zero,
            data objects' members will be enumerated and each one output on a separate line (up to the maximum).
            If zero, only the summary of data objects will be displayed.</param>
            <param name="expandExceptionStackTraces">Whether or not the log handler should expand pass-in exception objects to 
            display their associated stack traces. If true, stack traces will be shown below the corresponding log message.
            If false, only the summary (messages) of passed-in exceptions will be displayed.</param>
            <param name="customTimestampFormat">Custom timestamp format for appended timestamps. If this field is <c>null</c>,
            the default timestamp format (<see cref="F:Amber.BasicLogHandlerConfig.DEFAULT_TIMESTAMP_FORMAT"/>) will be used.</param>
        </member>
        <member name="T:Amber.ConsoleWriterLogHandler">
            <summary>
            An <see cref="T:Amber.ILogMessageHandler"/> that simply writes all received log messages to the <see cref="T:System.Console"/>.
            </summary>
        </member>
        <member name="M:Amber.ConsoleWriterLogHandler.#ctor">
            <summary>
            Creates a console writer with the default console writer configuration (reduced line noise, some information
            is not included for clarity's sake).
            </summary>
        </member>
        <member name="M:Amber.ConsoleWriterLogHandler.#ctor(Amber.LoggerSeverity)">
            <summary>
            Creates a console writer with the default console writer configuration (reduced line noise, some information
            is not included for clarity's sake) and a specified minimum severity level.
            </summary>
            <param name="minimumSeverity">The minimum severity level of messages to log. Messages with a lower severity
            level will be ignored.</param>
        </member>
        <member name="M:Amber.ConsoleWriterLogHandler.#ctor(Amber.BasicLogHandlerConfig)">
            <summary>
            Creates a console writer with the given custom configuration.
            </summary>
            <param name="configuration">The configuration to use that specifies how messages will be displayed on the console.</param>
        </member>
        <member name="M:Amber.ConsoleWriterLogHandler.HandleMessage(System.String)">
            <inheritdoc />
        </member>
        <member name="T:Amber.EnumerationRequestDataWrapper">
            <summary>
            A class wrapping a 'data' object that has been supplied in a <see cref="T:Amber.Log"/> call where the caller has specified
            that the log handler should enumerate the wrapped <see cref="F:Amber.EnumerationRequestDataWrapper.Enumerable"/>.
            </summary>
        </member>
        <member name="F:Amber.EnumerationRequestDataWrapper.Enumerable">
            <summary>
            The <see cref="T:System.Collections.IEnumerable"/> that the caller has requested be enumerated by the log handler.
            </summary>
        </member>
        <member name="T:Amber.FileWriterLogHandler">
            <summary>
            An <see cref="T:Amber.ILogMessageHandler"/> that simply writes all received log messages to a given file.
            </summary>
        </member>
        <member name="M:Amber.FileWriterLogHandler.#ctor(System.String)">
            <summary>
            Creates a default file writer that writes to the given file path with the default file writer configuration
            (writes all data, very verbose). If the file already exists, it will be appended to.
            </summary>
            <param name="filePath">The file to write to. Must be a valid and existing directory path, 
            but the file itself does not need to exist. If the file does exist, it will be appended to.</param>
        </member>
        <member name="M:Amber.FileWriterLogHandler.#ctor(System.String,System.Boolean)">
            <summary>
            Creates a default file writer that writes to the given file path with the default file writer configuration
            (writes all data, very verbose). If the file already exists, the value passed in to <paramref name="overwrite"/>
            will specify the behaviour of this handler.
            </summary>
            <param name="filePath">The file to write to. Must be a valid and existing directory path, 
            but the file itself does not need to exist. If the file does exist, it will be appended to.</param>
            <param name="overwrite">If the file exists and this value is <c>true</c>, the file will be overwritten.
            If <c>false</c>, the file will be appended to.</param>
        </member>
        <member name="M:Amber.FileWriterLogHandler.#ctor(System.String,Amber.LoggerSeverity)">
            <summary>
            Creates a default file writer that writes to the given file path with the default file writer configuration
            (writes all data, very verbose) and a specified minimum severity level. If the file already exists, it will be appended to.
            </summary>
            <param name="filePath">The file to write to. Must be a valid and existing directory path, 
            but the file itself does not need to exist. If the file does exist, it will be appended to.</param>
            <param name="minimumSeverity">The minimum severity level of messages to log. Messages with a lower severity
            level will be ignored.</param>
        </member>
        <member name="M:Amber.FileWriterLogHandler.#ctor(System.String,System.Boolean,Amber.LoggerSeverity)">
            <summary>
            Creates a default file writer that writes to the given file path with the default file writer configuration
            (writes all data, very verbose) and a specified minimum severity level.
            </summary>
            <param name="filePath">The file to write to. Must be a valid and existing directory path, 
            but the file itself does not need to exist. If the file does exist, it will be appended to.</param>
            <param name="overwrite">If the file exists and this value is <c>true</c>, the file will be overwritten.
            If <c>false</c>, the file will be appended to.</param>
            <param name="minimumSeverity">The minimum severity level of messages to log. Messages with a lower severity
            level will be ignored.</param>
        </member>
        <member name="M:Amber.FileWriterLogHandler.#ctor(System.String,Amber.BasicLogHandlerConfig)">
            <summary>
            Creates a file writer that writes to the given file path with the given file writer configuration.
            If the file already exists, it will be appended to.
            </summary>
            <param name="filePath">The file to write to. Must be a valid and existing directory path, 
            but the file itself does not need to exist. If the file does exist, it will be appended to.</param>
            <param name="configuration">The configuration to use that specifies how messages will be written to the file.</param>
        </member>
        <member name="M:Amber.FileWriterLogHandler.#ctor(System.String,System.Boolean,Amber.BasicLogHandlerConfig)">
            <summary>
            Creates a file writer that writes to the given file path with the given file writer configuration.
            </summary>
            <param name="filePath">The file to write to. Must be a valid and existing directory path, 
            but the file itself does not need to exist. If the file does exist, it will be appended to.</param>
            <param name="overwrite">If the file exists and this value is <c>true</c>, the file will be overwritten.
            If <c>false</c>, the file will be appended to.</param>
            <param name="configuration">The configuration to use that specifies how messages will be written to the file.</param>
        </member>
        <member name="M:Amber.FileWriterLogHandler.#ctor(Amber.IO.ITextReceiver,Amber.BasicLogHandlerConfig)">
            <summary>
            Creates a file writer that writes to the given <paramref name="textReceiver"/> with the given file writer configuration.
            </summary>
            <param name="textReceiver">The receiver that will handle processed log messages.</param>
            <param name="configuration">The configuration to use that specifies how messages will be written to the receiver.</param>
        </member>
        <member name="M:Amber.FileWriterLogHandler.HandleMessage(System.String)">
            <inheritdoc />
        </member>
        <member name="T:Amber.LoggerHandlerRemovalToken">
            <summary>
            A token representing a previously-added action-handler for the <see cref="T:Amber.Log"/>.
            Can be passed to <see cref="M:Amber.Log.RemoveHandler(Amber.LoggerHandlerRemovalToken)"/>.
            </summary>
        </member>
        <member name="T:Amber.BasicLogHandler">
            <summary>
            An <see cref="T:Amber.ILogMessageHandler"/> handler that preprocesses <see cref="T:Amber.Log"/> messages according to
            a given <see cref="F:Amber.BasicLogHandler.Configuration"/>.
            
            Child classes only need to implement <see cref="M:Amber.BasicLogHandler.HandleMessage(System.String)"/> to use the processed log messages.
            </summary>
        </member>
        <member name="F:Amber.BasicLogHandler.Configuration">
            <summary>
            The configuration for this log handler.
            </summary>
        </member>
        <member name="M:Amber.BasicLogHandler.#ctor(Amber.BasicLogHandlerConfig)">
            <summary>
            Create this <see cref="T:Amber.BasicLogHandler"/> and set its <see cref="F:Amber.BasicLogHandler.Configuration"/> to the given <paramref name="configuration"/>.
            </summary>
            <param name="configuration">The configuration to use for this handler.</param>
        </member>
        <member name="M:Amber.BasicLogHandler.ProcessMessage(System.String,Amber.LoggerSeverity,System.Exception,System.Object,System.String,System.String)">
            <summary>
            Called by the base class (<see cref="T:Amber.BasicLogHandler"/>) when a message needs to be processed.
            </summary>
            <param name="message">The user supplied message string. May be null.</param>
            <param name="messageSeverity">The user supplied message severity.</param>
            <param name="associatedException">The exception associated with this message if there is one, otherwise null.</param>
            <param name="associatedData">The data associated with this message if there is any, otherwise null.
            If the data represents a collection that the user wishes to be enumerated,
            it will be an <see cref="T:Amber.EnumerationRequestDataWrapper"/>.</param>
            <param name="callerFilePath">The file path of the code file containing the initial call to the <see cref="T:Amber.Log"/>.</param>
            <param name="callerMemberName">The name of the member that made the initial call to the <see cref="T:Amber.Log"/>.</param>
            <returns>A tuple whose first member indicates whether this message should be handled, and whose second member contains
            the processed message to be handled.</returns>
        </member>
        <member name="M:Amber.BasicLogHandler.HandleMessage(System.String)">
            <summary>
            Called by the base class (<see cref="T:Amber.BasicLogHandler"/>) when a message has been processed.
            </summary>
            <param name="message">The processed message to handle.</param>
        </member>
        <member name="T:Amber.Log">
            <summary>
            Presents an interface for all Amber applications and libraries to write data to log handlers.
            </summary>
        </member>
        <member name="M:Amber.Log.AddHandler(System.Action{System.String})">
            <summary>
            Add a simple log handler that performs the given action with every processed message, using a default logger configuration
            that includes all data.
            </summary>
            <param name="handler">The action to perform for every log message. Must not be null.</param>
            <returns>A removal token that can be used to unregister the handler later 
            (with <see cref="M:Amber.Log.RemoveHandler(Amber.LoggerHandlerRemovalToken)"/>).</returns>
        </member>
        <member name="M:Amber.Log.AddHandler(System.Action{System.String},Amber.LoggerSeverity)">
            <summary>
            Add a simple log handler that performs the given action with every processed message, using a default logger configuration
            that includes all data at or above the given <paramref name="minimumSeverity"/>.
            </summary>
            <param name="handler">The action to perform for every log message. Must not be null.</param>
            <param name="minimumSeverity">The minimum severity level of messages to log. Messages with a lower severity
            level will not be passed to the <paramref name="handler"/> action.</param>
            <returns>A removal token that can be used to unregister the handler later 
            (with <see cref="M:Amber.Log.RemoveHandler(Amber.LoggerHandlerRemovalToken)"/>).</returns>
        </member>
        <member name="M:Amber.Log.AddHandler(System.Action{System.String},Amber.BasicLogHandlerConfig)">
            <summary>
            Add a simple log handler that performs the given action with every processed message; specifying a configuration
            object that specifies how the messages are preprocessed before being passed to <paramref name="handler"/>.
            </summary>
            <param name="handler">The action to perform for every log message. Must not be null.</param>
            <param name="preprocessingConfig">A configuration object that specifies how messages should be preprocessed
            before being passed to the given <paramref name="handler"/>.</param>
            <returns>A removal token that can be used to unregister the handler later 
            (with <see cref="M:Amber.Log.RemoveHandler(Amber.LoggerHandlerRemovalToken)"/>).</returns>
        </member>
        <member name="M:Amber.Log.RemoveHandler(Amber.LoggerHandlerRemovalToken)">
            <summary>
            Removes a simple-action handler that was previously created with a call to <see cref="M:Amber.Log.AddHandler(System.Action{System.String})"/>
            or one of its overloads.
            </summary>
            <param name="token">The token representing the previously added handler.</param>
        </member>
        <member name="M:Amber.Log.AddHandler(Amber.ILogMessageHandler)">
            <summary>
            Add a custom log message handler.
            </summary>
            <seealso cref="T:Amber.ConsoleWriterLogHandler"/>
            <seealso cref="T:Amber.FileWriterLogHandler"/>
            <param name="handler">The handler to add. Must not be null.</param>
        </member>
        <member name="M:Amber.Log.RemoveHandler(Amber.ILogMessageHandler)">
            <summary>
            Remove a previously added custom log message handler.
            </summary>
            <param name="handler">The handler to remove. Must not be null, and must be currently added.</param>
        </member>
        <member name="M:Amber.Log.Debug(System.String,System.Object,System.Exception,System.String,System.String)">
            <summary>
            Write the given message and data to the log handlers.
            The severity level logged will be <see cref="F:Amber.LoggerSeverity.Debug"/>.
            </summary>
            <param name="message">The message to write. Null is permitted.</param>
            <param name="data">The object you wish to include in the log data.</param>
            <param name="e">The exception you wish to include in the log data.</param>
            <param name="callerFilePath">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
            <param name="callerMemberName">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
        </member>
        <member name="M:Amber.Log.Debug(System.String,System.Object,System.Boolean,System.String,System.String)">
            <summary>
            Write the given message and data to the log handlers.
            The severity level logged will be <see cref="F:Amber.LoggerSeverity.Debug"/>.
            </summary>
            <param name="message">The message to write. Null is permitted.</param>
            <param name="data">The object you wish to include in the log data.</param>
            <param name="enumerateData">If <c>true</c>, the <paramref name="data"/> will be enumerated in the log output.
            If <c>false</c>, the data will be processed as usual.</param>
            <param name="callerFilePath">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
            <param name="callerMemberName">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
        </member>
        <member name="M:Amber.Log.Debug(System.String,System.Exception,System.String,System.String)">
            <summary>
            Write the given message and data to the log handlers.
            The severity level logged will be <see cref="F:Amber.LoggerSeverity.Debug"/>.
            </summary>
            <param name="message">The message to write. Null is permitted.</param>
            <param name="e">The exception you wish to include in the log data.</param>
            <param name="callerFilePath">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
            <param name="callerMemberName">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
        </member>
        <member name="M:Amber.Log.Debug(System.String,System.Object,System.Boolean,System.Exception,System.String,System.String)">
            <summary>
            Write the given message and data to the log handlers.
            The severity level logged will be <see cref="F:Amber.LoggerSeverity.Debug"/>.
            </summary>
            <param name="message">The message to write. Null is permitted.</param>
            <param name="data">The object you wish to include in the log data.</param>
            <param name="enumerateData">If <c>true</c>, the <paramref name="data"/> will be enumerated in the log output.
            If <c>false</c>, the data will be processed as usual.</param>
            <param name="e">The exception you wish to include in the log data.</param>
            <param name="callerFilePath">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
            <param name="callerMemberName">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
        </member>
        <member name="M:Amber.Log.Info(System.String,System.Object,System.Exception,System.String,System.String)">
            <summary>
            Write the given message and data to the log handlers.
            The severity level logged will be <see cref="F:Amber.LoggerSeverity.Info"/>.
            </summary>
            <param name="message">The message to write. Null is permitted.</param>
            <param name="data">The object you wish to include in the log data.</param>
            <param name="e">The exception you wish to include in the log data.</param>
            <param name="callerFilePath">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
            <param name="callerMemberName">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
        </member>
        <member name="M:Amber.Log.Info(System.String,System.Object,System.Boolean,System.String,System.String)">
            <summary>
            Write the given message and data to the log handlers.
            The severity level logged will be <see cref="F:Amber.LoggerSeverity.Info"/>.
            </summary>
            <param name="message">The message to write. Null is permitted.</param>
            <param name="data">The object you wish to include in the log data.</param>
            <param name="enumerateData">If <c>true</c>, the <paramref name="data"/> will be enumerated in the log output.
            If <c>false</c>, the data will be processed as usual.</param>
            <param name="callerFilePath">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
            <param name="callerMemberName">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
        </member>
        <member name="M:Amber.Log.Info(System.String,System.Exception,System.String,System.String)">
            <summary>
            Write the given message and data to the log handlers.
            The severity level logged will be <see cref="F:Amber.LoggerSeverity.Info"/>.
            </summary>
            <param name="message">The message to write. Null is permitted.</param>
            <param name="e">The exception you wish to include in the log data.</param>
            <param name="callerFilePath">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
            <param name="callerMemberName">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
        </member>
        <member name="M:Amber.Log.Info(System.String,System.Object,System.Boolean,System.Exception,System.String,System.String)">
            <summary>
            Write the given message and data to the log handlers.
            The severity level logged will be <see cref="F:Amber.LoggerSeverity.Info"/>.
            </summary>
            <param name="message">The message to write. Null is permitted.</param>
            <param name="data">The object you wish to include in the log data.</param>
            <param name="enumerateData">If <c>true</c>, the <paramref name="data"/> will be enumerated in the log output.
            If <c>false</c>, the data will be processed as usual.</param>
            <param name="e">The exception you wish to include in the log data.</param>
            <param name="callerFilePath">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
            <param name="callerMemberName">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
        </member>
        <member name="M:Amber.Log.Warn(System.String,System.Object,System.Exception,System.String,System.String)">
            <summary>
            Write the given message and data to the log handlers.
            The severity level logged will be <see cref="F:Amber.LoggerSeverity.Warning"/>.
            </summary>
            <param name="message">The message to write. Null is permitted.</param>
            <param name="data">The object you wish to include in the log data.</param>
            <param name="e">The exception you wish to include in the log data.</param>
            <param name="callerFilePath">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
            <param name="callerMemberName">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
        </member>
        <member name="M:Amber.Log.Warn(System.String,System.Object,System.Boolean,System.String,System.String)">
            <summary>
            Write the given message and data to the log handlers.
            The severity level logged will be <see cref="F:Amber.LoggerSeverity.Warning"/>.
            </summary>
            <param name="message">The message to write. Null is permitted.</param>
            <param name="data">The object you wish to include in the log data.</param>
            <param name="enumerateData">If <c>true</c>, the <paramref name="data"/> will be enumerated in the log output.
            If <c>false</c>, the data will be processed as usual.</param>
            <param name="callerFilePath">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
            <param name="callerMemberName">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
        </member>
        <member name="M:Amber.Log.Warn(System.String,System.Exception,System.String,System.String)">
            <summary>
            Write the given message and data to the log handlers.
            The severity level logged will be <see cref="F:Amber.LoggerSeverity.Warning"/>.
            </summary>
            <param name="message">The message to write. Null is permitted.</param>
            <param name="e">The exception you wish to include in the log data.</param>
            <param name="callerFilePath">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
            <param name="callerMemberName">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
        </member>
        <member name="M:Amber.Log.Warn(System.String,System.Object,System.Boolean,System.Exception,System.String,System.String)">
            <summary>
            Write the given message and data to the log handlers.
            The severity level logged will be <see cref="F:Amber.LoggerSeverity.Warning"/>.
            </summary>
            <param name="message">The message to write. Null is permitted.</param>
            <param name="data">The object you wish to include in the log data.</param>
            <param name="enumerateData">If <c>true</c>, the <paramref name="data"/> will be enumerated in the log output.
            If <c>false</c>, the data will be processed as usual.</param>
            <param name="e">The exception you wish to include in the log data.</param>
            <param name="callerFilePath">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
            <param name="callerMemberName">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
        </member>
        <member name="M:Amber.Log.Error(System.String,System.Object,System.Exception,System.String,System.String)">
            <summary>
            Write the given message and data to the log handlers.
            The severity level logged will be <see cref="F:Amber.LoggerSeverity.Error"/>.
            </summary>
            <param name="message">The message to write. Null is permitted.</param>
            <param name="data">The object you wish to include in the log data.</param>
            <param name="e">The exception you wish to include in the log data.</param>
            <param name="callerFilePath">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
            <param name="callerMemberName">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
        </member>
        <member name="M:Amber.Log.Error(System.String,System.Object,System.Boolean,System.String,System.String)">
            <summary>
            Write the given message and data to the log handlers.
            The severity level logged will be <see cref="F:Amber.LoggerSeverity.Error"/>.
            </summary>
            <param name="message">The message to write. Null is permitted.</param>
            <param name="data">The object you wish to include in the log data.</param>
            <param name="enumerateData">If <c>true</c>, the <paramref name="data"/> will be enumerated in the log output.
            If <c>false</c>, the data will be processed as usual.</param>
            <param name="callerFilePath">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
            <param name="callerMemberName">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
        </member>
        <member name="M:Amber.Log.Error(System.String,System.Exception,System.String,System.String)">
            <summary>
            Write the given message and data to the log handlers.
            The severity level logged will be <see cref="F:Amber.LoggerSeverity.Error"/>.
            </summary>
            <param name="message">The message to write. Null is permitted.</param>
            <param name="e">The exception you wish to include in the log data.</param>
            <param name="callerFilePath">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
            <param name="callerMemberName">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
        </member>
        <member name="M:Amber.Log.Error(System.String,System.Object,System.Boolean,System.Exception,System.String,System.String)">
            <summary>
            Write the given message and data to the log handlers.
            The severity level logged will be <see cref="F:Amber.LoggerSeverity.Error"/>.
            </summary>
            <param name="message">The message to write. Null is permitted.</param>
            <param name="data">The object you wish to include in the log data.</param>
            <param name="enumerateData">If <c>true</c>, the <paramref name="data"/> will be enumerated in the log output.
            If <c>false</c>, the data will be processed as usual.</param>
            <param name="e">The exception you wish to include in the log data.</param>
            <param name="callerFilePath">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
            <param name="callerMemberName">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
        </member>
        <member name="M:Amber.Log.Fatal(System.String,System.Object,System.Exception,System.String,System.String)">
            <summary>
            Write the given message and data to the log handlers.
            The severity level logged will be <see cref="F:Amber.LoggerSeverity.Fatal"/>.
            </summary>
            <param name="message">The message to write. Null is permitted.</param>
            <param name="data">The object you wish to include in the log data.</param>
            <param name="e">The exception you wish to include in the log data.</param>
            <param name="callerFilePath">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
            <param name="callerMemberName">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
        </member>
        <member name="M:Amber.Log.Fatal(System.String,System.Object,System.Boolean,System.String,System.String)">
            <summary>
            Write the given message and data to the log handlers.
            The severity level logged will be <see cref="F:Amber.LoggerSeverity.Fatal"/>.
            </summary>
            <param name="message">The message to write. Null is permitted.</param>
            <param name="data">The object you wish to include in the log data.</param>
            <param name="enumerateData">If <c>true</c>, the <paramref name="data"/> will be enumerated in the log output.
            If <c>false</c>, the data will be processed as usual.</param>
            <param name="callerFilePath">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
            <param name="callerMemberName">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
        </member>
        <member name="M:Amber.Log.Fatal(System.String,System.Exception,System.String,System.String)">
            <summary>
            Write the given message and data to the log handlers.
            The severity level logged will be <see cref="F:Amber.LoggerSeverity.Fatal"/>.
            </summary>
            <param name="message">The message to write. Null is permitted.</param>
            <param name="e">The exception you wish to include in the log data.</param>
            <param name="callerFilePath">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
            <param name="callerMemberName">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
        </member>
        <member name="M:Amber.Log.Fatal(System.String,System.Object,System.Boolean,System.Exception,System.String,System.String)">
            <summary>
            Write the given message and data to the log handlers.
            The severity level logged will be <see cref="F:Amber.LoggerSeverity.Fatal"/>.
            </summary>
            <param name="message">The message to write. Null is permitted.</param>
            <param name="data">The object you wish to include in the log data.</param>
            <param name="enumerateData">If <c>true</c>, the <paramref name="data"/> will be enumerated in the log output.
            If <c>false</c>, the data will be processed as usual.</param>
            <param name="e">The exception you wish to include in the log data.</param>
            <param name="callerFilePath">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
            <param name="callerMemberName">This field is filled in by the compiler. Do not specify a value (simply ignore it).</param>
        </member>
        <member name="T:Amber.LoggerSeverity">
            <summary>
            Represents a severity level for log messages.
            </summary>
        </member>
        <member name="F:Amber.LoggerSeverity.Debug">
            <summary>
            Indicates values used only for debugging and diagnostic purposes.
            </summary>
        </member>
        <member name="F:Amber.LoggerSeverity.Info">
            <summary>
            Indicates general process monitoring/instrumenting data.
            </summary>
        </member>
        <member name="F:Amber.LoggerSeverity.Warning">
            <summary>
            Indicates a potential misconfiguration or forthcoming error.
            </summary>
        </member>
        <member name="F:Amber.LoggerSeverity.Error">
            <summary>
            Indicates a serious failure.
            </summary>
        </member>
        <member name="F:Amber.LoggerSeverity.Fatal">
            <summary>
            Indicates a serious failure that the application can not recover from/continue with.
            </summary>
        </member>
        <member name="T:Amber.ILogMessageHandler">
            <summary>
            Represents an object that can process and handle messages as they are passed to the <see cref="T:Amber.Log"/>.
            </summary>
        </member>
        <member name="M:Amber.ILogMessageHandler.ProcessMessage(System.String,Amber.LoggerSeverity,System.Exception,System.Object,System.String,System.String)">
            <summary>
            Called by the logger when a user attempts to write a log message. This function must process the incoming data
            in to a single string which will then be 'handled' in <see cref="M:Amber.ILogMessageHandler.HandleProcessedMessage(System.String)"/>.
            </summary>
            <param name="message">The user-supplied 'message' string.</param>
            <param name="messageSeverity">The message severity.</param>
            <param name="associatedException">The associated exception supplied by the user.
            Will be <c>null</c> if no exception was given.</param>
            <param name="associatedData">The associated data supplied by the user.
            Will be <c>null</c> if no data was given. If the data is an <see cref="T:System.Collections.IEnumerable"/> and the user is
            requesting this handler to enumerate that data in the log, it will be wrapped in 
            an <see cref="T:Amber.EnumerationRequestDataWrapper"/>; where the actual data itself is referenced in the
            <see cref="F:Amber.EnumerationRequestDataWrapper.Enumerable"/> field.</param>
            <param name="callerFilePath">The file path of the file containing the member that initially
            called the <see cref="T:Amber.Log"/> method.</param>
            <param name="callerMemberName">The name of the member that initially called the <see cref="T:Amber.Log"/> method.</param>
            <returns>A tuple containing:
            <para>- Whether this handler should continue handling the message,</para>
            <para>- The message to be handled (may be null).</para>
            </returns>
        </member>
        <member name="M:Amber.ILogMessageHandler.HandleProcessedMessage(System.String)">
            <summary>
            Called by the logger when this handler has processed a message and indicated that it should be handled.
            </summary>
            <param name="processedMessage">The previously-processed message to handle.</param>
        </member>
        <member name="T:Amber.SingleLineCompressingLogHandler">
            <summary>
            A log message handler that compresses all data in to a single line (useful for console outputs etc).
            </summary>
        </member>
        <member name="M:Amber.SingleLineCompressingLogHandler.#ctor(System.Action{System.String})">
            <summary>
            Create a new compressing log handler that performs the given action with every incoming log line.
            Caller data (file name, member name) are not included in the output. All severity levels are included.
            </summary>
            <param name="handlerAction">The action to perform with every line.</param>
        </member>
        <member name="M:Amber.SingleLineCompressingLogHandler.#ctor(System.Action{System.String},Amber.LoggerSeverity,System.Boolean)">
            <summary>
            Create a new compressing log handler that performs the given action with every incoming log line.
            </summary>
            <param name="handlerAction">The action to perform with every line.</param>
            <param name="minSeverity">The minimum severity level of message to log. Messages less severe than this
            level will be discarded.</param>
            <param name="includeCallerData">Whether or not to include caller data (file name, member name) in the output.</param>
        </member>
        <member name="M:Amber.MaybeExtensions.DefaultIfNothing``1(Amber.IMaybe{``0},``0)">
            <summary>
            Returns a default value if this Maybe contains Nothing.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="m"></param>
            <param name="defaultValue">The default value to use.
            The calling code must ensure it is not null for reference types!</param>
            <returns></returns>
        </member>
        <member name="M:Amber.MaybeExtensions.DefaultIfNothing``1(Amber.IMaybe{``0},Amber.IMaybe{``0})">
            <summary>
            Returns a default value if this Maybe contains Nothing.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="m"></param>
            <param name="nothingValue">The default value to use.</param>
            <returns></returns>
        </member>
        <member name="M:Amber.MaybeExtensions.DefaultIfNothing``1(Amber.IMaybe{``0},System.Func{``0})">
            <summary>
            Returns a lazily-evaluated default value if this Maybe contains Nothing.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="m"></param>
            <param name="nothingReturn">A function to produce a default value, called lazily only if this contains Nothing.</param>
            <returns></returns>
        </member>
        <member name="M:Amber.MaybeExtensions.DefaultIfNothing``1(Amber.IMaybe{``0},System.Func{Amber.IMaybe{``0}})">
            <summary>
            Returns a lazily-evaluated default value if this Maybe contains Nothing.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="m"></param>
            <param name="nothingReturn">A function to produce a default value, called lazily only if this contains Nothing.</param>
            <returns></returns>
        </member>
        <member name="T:Amber.Result`1">
            <summary>
            Represents the result of an operation that may have failed or succeeded returning an object of type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type of object returned by the most recent operation represented by this result (if successful).</typeparam>
        </member>
        <member name="T:Amber.Success`1">
            <summary>
            Represents a successfully completed operation that returned an object of type <typeparamref name="T"/>. The returned object
            can be accessed with the <see cref="P:Amber.Success`1.Result"/> property.
            </summary>
            <typeparam name="T">The type of object returned by the successful operation.</typeparam>
        </member>
        <member name="P:Amber.Success`1.Result">
            <summary>
            The object returned by the successful operation.
            </summary>
        </member>
        <member name="M:Amber.Success`1.ToString">
            <summary>
            Returns a string representing the successful <see cref="P:Amber.Success`1.Result"/> object.
            </summary>
            <returns><c>Result.ToString()</c></returns>
        </member>
        <member name="T:Amber.Failure`1">
            <summary>
            Represents an operation returning an object of type <typeparamref name="T"/> that failed. A message explaining the failure
            is accessible via the <see cref="P:Amber.Failure`1.Message"/> property.
            </summary>
            <typeparam name="T">The type of object that would have been returned by the operation if it had succeeded.</typeparam>
        </member>
        <member name="P:Amber.Failure`1.Message">
            <summary>
            A message explaining why this operation (or one before it) failed.
            </summary>
        </member>
        <member name="M:Amber.Failure`1.ToString">
            <summary>
            Returns a string representing the failure reason.
            </summary>
            <returns><see cref="P:Amber.Failure`1.Message"/></returns>
        </member>
        <member name="T:Amber.Result">
            <summary>
            A static class containing factory methods and helpers for constructing <see cref="T:Amber.Result`1"/>, <see cref="T:Amber.Failure`1"/>,
            and <see cref="T:Amber.Success`1"/> monads.
            </summary>
        </member>
        <member name="M:Amber.Result.Success``1(``0)">
            <summary>
            Create a <see cref="T:Amber.Success`1"/> from the given successfully-returned <paramref name="value"/>.
            </summary>
            <typeparam name="T">The type of <paramref name="value"/>. If <paramref name="value"/> is <c>null</c>, this
            method returns a <see cref="T:Amber.Failure`1"/>.</typeparam>
            <param name="value">The object that was successfully returned from an operation.</param>
            <returns>A <see cref="T:Amber.Success`1"/> encapsulating the given <paramref name="value"/> as a <see cref="T:Amber.Result`1"/>.</returns>
        </member>
        <member name="M:Amber.Result.Failure``1(System.String)">
            <summary>
            Create a <see cref="T:Amber.Failure`1"/> from the given failure <paramref name="message"/>.
            </summary>
            <typeparam name="T">The type of object that would have been returned from the operation this failure represents,
            if it had succeeded instead.</typeparam>
            <param name="message">A message explaining the failure. May be null.</param>
            <returns>A <see cref="T:Amber.Failure`1"/> encapsulating the given <paramref name="message"/> as a <see cref="T:Amber.Result`1"/>.</returns>
        </member>
        <member name="M:Amber.Result.Bind``1(Amber.Result{``0},System.Func{``0,Amber.Result{``0}})">
            <summary>
            Bind the result from a second function call to this result.
            </summary>
            <typeparam name="A">The type of object returned from a successful operation.</typeparam>
            <param name="this">The extended result.</param>
            <param name="func">If this result represents a <see cref="T:Amber.Success`1"/>, this function will be called
            with the <see cref="P:Amber.Success`1.Result"/> of that success. The function should then return a new <see cref="T:Amber.Result`1"/>
            that reflects the outcome of its own operation.
            </param>
            <returns>If this is a <see cref="T:Amber.Success`1"/>, the <see cref="T:Amber.Result`1"/> returned by <paramref name="func"/>.
            Otherwise, a <see cref="T:Amber.Failure`1"/>.</returns>
        </member>
        <member name="M:Amber.Result.Bind``2(Amber.Result{``0},System.Func{``0,Amber.Result{``1}})">
            <summary>
            Bind the result from a second function call to this result.
            </summary>
            <typeparam name="A">The type of object returned from this result if it represents a success.</typeparam>
            <typeparam name="B">The type of object returned from a successful invocation of the operation represented
            by <paramref name="func"/>.</typeparam>
            <param name="this">The extended result.</param>
            <param name="func">If this result represents a <see cref="T:Amber.Success`1"/>, this function will be called
            with the <see cref="P:Amber.Success`1.Result"/> of that success. The function should then return a new <see cref="T:Amber.Result`1"/>
            that reflects the outcome of its own operation.</param>
            <returns>If this is a <see cref="T:Amber.Success`1"/>, the <see cref="T:Amber.Result`1"/> returned by <paramref name="func"/>.
            Otherwise, a <see cref="T:Amber.Failure`1"/>.</returns>
        </member>
        <member name="M:Amber.Result.Do``1(Amber.Result{``0},System.Action{``0})">
            <summary>
            Perform the given <paramref name="action"/> only if this result represents a <see cref="T:Amber.Success`1"/>.
            </summary>
            <typeparam name="A">The type of object returned from this result if it represents a success.</typeparam>
            <param name="this">The extended result.</param>
            <param name="action">The action that will be called with the <see cref="P:Amber.Success`1.Result"/> of this 
            <see cref="T:Amber.Result`1"/> if it represents a <see cref="T:Amber.Success`1"/>.</param>
        </member>
        <member name="M:Amber.Result.Do``1(Amber.Result{``0},System.Action{``0},System.Action{System.String})">
            <summary>
            Perform the given <paramref name="successAction"/> if this result represents a <see cref="T:Amber.Success`1"/>. Otherwise,
            perform the given <paramref name="failureAction"/>.
            </summary>
            <typeparam name="A">The type of object returned from this result if it represents a success.</typeparam>
            <param name="this">The extended result.</param>
            <param name="successAction">The action that will be called with the <see cref="P:Amber.Success`1.Result"/> of this 
            <see cref="T:Amber.Result`1"/> if it represents a <see cref="T:Amber.Success`1"/>.</param>
            <param name="failureAction">The action that will be called with the <see cref="P:Amber.Failure`1.Message"/> of this 
            <see cref="T:Amber.Result`1"/> if it represents a <see cref="T:Amber.Failure`1"/>.</param>
        </member>
        <member name="M:Amber.Result.SelectMany``3(Amber.Result{``0},System.Func{``0,Amber.Result{``1}},System.Func{``0,``1,``2})">
            <summary>
            Binds this result to the result returned by <paramref name="func"/>; and if both results are <see cref="T:Amber.Success`1"/>es
            passes both result objects to the given <paramref name="selector"/>; which will return a new value of type
            <typeparamref name="C"/> that will be encapsulated in a final <see cref="T:Amber.Result`1"/>. If any of the <see cref="T:Amber.Result`1"/>
            objects along the entire chain of calls is a <see cref="T:Amber.Failure`1"/>,
            this method will return a <see cref="T:Amber.Failure`1"/>.
            </summary>
            <typeparam name="A">The type of object returned by the operation this result represents.</typeparam>
            <typeparam name="B">The type of object returned by the operation that the given <paramref name="func"/> encapsulates.</typeparam>
            <typeparam name="C">The final type of object that the <paramref name="selector"/> func returns.</typeparam>
            <param name="this">The extended result.</param>
            <param name="func">A function that takes the value encapsulated by this result if it is a success, and generates a new
            result that potentially returns a value of type <typeparamref name="B"/>.</param>
            <param name="selector">A function that takes the value of this result and the result returned by the <paramref name="func"/>,
            and returns a third value.</param>
            <returns>A <see cref="T:Amber.Success`1"/> of type <typeparamref name="C"/> if there are no failures, or a
            <see cref="T:Amber.Failure`1"/> if there are (or if the <paramref name="selector"/> func returns <c>null</c>).</returns>
        </member>
        <member name="M:Amber.Result.SelectMany``2(Amber.Result{``0},System.Func{``0,Amber.Result{``1}})">
            <summary>
            Bind the result from a second function call to this result.
            </summary>
            <typeparam name="A">The type of object returned from this result if it represents a success.</typeparam>
            <typeparam name="B">The type of object returned from a successful invocation of the operation represented
            by <paramref name="func"/>.</typeparam>
            <param name="this">The extended result.</param>
            <param name="func">If this result represents a <see cref="T:Amber.Success`1"/>, this function will be called
            with the <see cref="P:Amber.Success`1.Result"/> of that success. The function should then return a new <see cref="T:Amber.Result`1"/>
            that reflects the outcome of its own operation.</param>
            <returns>If this is a <see cref="T:Amber.Success`1"/>, the <see cref="T:Amber.Result`1"/> returned by <paramref name="func"/>.
            Otherwise, a <see cref="T:Amber.Failure`1"/>.</returns>
        </member>
        <member name="M:Amber.Result.Select``2(Amber.Result{``0},System.Func{``0,Amber.Result{``1}})">
            <summary>
            Bind the result from a second function call to this result.
            </summary>
            <typeparam name="A">The type of object returned from this result if it represents a success.</typeparam>
            <typeparam name="B">The type of object returned from a successful invocation of the operation represented
            by <paramref name="func"/>.</typeparam>
            <param name="this">The extended result.</param>
            <param name="func">If this result represents a <see cref="T:Amber.Success`1"/>, this function will be called
            with the <see cref="P:Amber.Success`1.Result"/> of that success. The function should then return a new <see cref="T:Amber.Result`1"/>
            that reflects the outcome of its own operation.</param>
            <returns>If this is a <see cref="T:Amber.Success`1"/>, the <see cref="T:Amber.Result`1"/> returned by <paramref name="func"/>.
            Otherwise, a <see cref="T:Amber.Failure`1"/>.</returns>
        </member>
        <member name="M:Amber.Result.Switch``2(Amber.Result{``0},System.Func{``0,Amber.Result{``1}},System.Func{System.String,Amber.Result{``1}})">
            <summary>
            Return a <see cref="T:Amber.Result`1"/> of type <typeparamref name="B"/> using a <paramref name="successFunc"/> or
            <paramref name="failFunc"/> depending on whether or not this result is a <see cref="T:Amber.Success`1"/> or
            <see cref="T:Amber.Failure`1"/>.
            </summary>
            <typeparam name="A">The type of object returned by a successful invocation of the operation this result represents.</typeparam>
            <typeparam name="B">The type of object returned by a successful invocation of the operation the <paramref name="successFunc"/>
            and <paramref name="failFunc"/> represent.</typeparam>
            <param name="this">The extended result.</param>
            <param name="successFunc">A function that will be called if this is a <see cref="T:Amber.Success`1"/>.</param>
            <param name="failFunc">A function that will be called if this is a <see cref="T:Amber.Failure`1"/>.</param>
            <returns>Either the return value of <paramref name="successFunc"/> or of <paramref name="failFunc"/>.</returns>
        </member>
        <member name="M:Amber.Result.Map``2(Amber.Result{``0},System.Func{``0,``1},System.Func{System.String,System.String})">
            <summary>
            Similar to <see cref="M:Amber.Result.Switch``2(Amber.Result{``0},System.Func{``0,Amber.Result{``1}},System.Func{System.String,Amber.Result{``1}})"/>, but simplifies the procedure by simply mapping the captured result type
            (from <typeparamref name="A"/> to <typeparamref name="B"/>). In other words, successes are always mapped to successes,
            and failures always to failures.
            </summary>
            <typeparam name="A">The type of object returned by a successful invocation of the operation this result represents.</typeparam>
            <typeparam name="B">The mapped-to type.</typeparam>
            <param name="this">The extended result.</param>
            <param name="successMap">Maps the <see cref="P:Amber.Success`1.Result"/> of <paramref name="this"/> if <paramref name="this"/>
            is a <see cref="T:Amber.Success`1"/> to a new <see cref="T:Amber.Success`1"/> of type <typeparamref name="B"/>.</param>
            <param name="failMap">Maps the <see cref="P:Amber.Failure`1.Message"/> of <paramref name="this"/> if 
            <paramref name="this"/> is a <see cref="T:Amber.Failure`1"/> to a new <see cref="T:Amber.Failure`1"/> of type
            <typeparamref name="B"/>.</param>
            <returns>A new <see cref="T:Amber.Result`1"/> of type <typeparamref name="B"/>.</returns>
        </member>
        <member name="M:Amber.Result.Map``2(Amber.Result{``0},System.Func{``0,``1})">
            <summary>
            Similar to <see cref="M:Amber.Result.Switch``2(Amber.Result{``0},System.Func{``0,Amber.Result{``1}},System.Func{System.String,Amber.Result{``1}})"/>, but simplifies the procedure by simply mapping the captured result type
            (from <typeparamref name="A"/> to <typeparamref name="B"/>). In other words, successes are always mapped to successes,
            and failures always to failures. In this overload, if <paramref name="this"/> is a <see cref="T:Amber.Failure`1"/>,
            the failure <see cref="P:Amber.Failure`1.Message"/> is simply passed-through. To alter the message instead, use
            <see cref="M:Amber.Result.Map``2(Amber.Result{``0},System.Func{``0,``1},System.Func{System.String,System.String})"/>.
            </summary>
            <typeparam name="A">The type of object returned by a successful invocation of the operation this result represents.</typeparam>
            <typeparam name="B">The mapped-to type.</typeparam>
            <param name="this">The extended result.</param>
            <param name="successMap">Maps the <see cref="P:Amber.Success`1.Result"/> of <paramref name="this"/> if <paramref name="this"/>
            is a <see cref="T:Amber.Success`1"/> to a new <see cref="T:Amber.Success`1"/> of type <typeparamref name="B"/>.</param>
            <returns>A new <see cref="T:Amber.Result`1"/> of type <typeparamref name="B"/>.</returns>
        </member>
        <member name="M:Amber.Result.Fold``2(Amber.Result{``0},System.Func{``0,``1},``1)">
            <summary>
            Fold this <see cref="T:Amber.Result`1"/> to a single value of type <typeparamref name="B"/>. If this result is a
            <see cref="T:Amber.Success`1"/>, the given <paramref name="successMapFunc"/> will be called with the
            <see cref="P:Amber.Success`1.Result"/> as the input parameter. Alternatively, if this result is a <see cref="T:Amber.Failure`1"/>,
            the <paramref name="failureDefault"/> will be returned instead.
            </summary>
            <typeparam name="A">The original result type.</typeparam>
            <typeparam name="B">The return type.</typeparam>
            <param name="this">The extended result.</param>
            <param name="successMapFunc">Function called if <paramref name="this"/> is a <see cref="T:Amber.Success`1"/>. The input
            parameter is the <see cref="P:Amber.Success`1.Result"/>, and the output value will be returned from this function call.</param>
            <param name="failureDefault">Value returned if <paramref name="this"/> is a <see cref="T:Amber.Failure`1"/>.</param>
            <returns>Either the output from <paramref name="successMapFunc"/> or the given <paramref name="failureDefault"/>,
            depending on whether <paramref name="this"/> is a <see cref="T:Amber.Success`1"/> or a <see cref="T:Amber.Failure`1"/>.</returns>
        </member>
        <member name="M:Amber.Result.Fold``2(Amber.Result{``0},System.Func{``0,``1},System.Func{``1})">
            <summary>
            Fold this <see cref="T:Amber.Result`1"/> to a single value of type <typeparamref name="B"/>. If this result is a
            <see cref="T:Amber.Success`1"/>, the given <paramref name="successMapFunc"/> will be called with the
            <see cref="P:Amber.Success`1.Result"/> as the input parameter. Alternatively, if this result is a <see cref="T:Amber.Failure`1"/>,
            the <paramref name="failureDefaultGeneratorFunc"/> will be called instead.
            </summary>
            <typeparam name="A">The original result type.</typeparam>
            <typeparam name="B">The return type.</typeparam>
            <param name="this">The extended result.</param>
            <param name="successMapFunc">Function called if <paramref name="this"/> is a <see cref="T:Amber.Success`1"/>. The input
            parameter is the <see cref="P:Amber.Success`1.Result"/>, and the output value will be returned from this function call.</param>
            <param name="failureDefaultGeneratorFunc">Function called if <paramref name="this"/> is a <see cref="T:Amber.Failure`1"/>.
            The output value will be returned from this function call.</param>
            <returns>The output from either <paramref name="successMapFunc"/> or <paramref name="failureDefaultGeneratorFunc"/>,
            depending on whether <paramref name="this"/> is a <see cref="T:Amber.Success`1"/> or a <see cref="T:Amber.Failure`1"/>.</returns>
        </member>
        <member name="M:Amber.Result.GetResult``2(System.Collections.Generic.Dictionary{``0,``1},``0)">
            <summary>
            Attempt to get a value out of this dictionary with the given <paramref name="key"/>; wrapping the operation in a
            <see cref="T:Amber.Result`1"/>.
            </summary>
            <typeparam name="TKey">The key type of this dictionary.</typeparam>
            <typeparam name="TValue">The value type of this dictionary.</typeparam>
            <param name="this">The extended dictionary.</param>
            <param name="key">The key for the value you wish to access.</param>
            <returns>If the key exists, a <see cref="T:Amber.Success`1"/> is returned whose <see cref="P:Amber.Success`1.Result"/>
            is the value of the retreived item in the dictionary. If the key does not exist, a <see cref="T:Amber.Failure`1"/> is returned.
            </returns>
        </member>
        <member name="M:Amber.Result.Where``1(System.Collections.Generic.IEnumerable{Amber.Result{``0}})">
            <summary>
            Select only successful results from this sequence.
            </summary>
            <typeparam name="A">The type of result's potential value.</typeparam>
            <param name="this">The extended enumerable.</param>
            <returns>An enumeration of values that are encapsulated by <see cref="T:Amber.Success`1"/>es in this sequence. Any
            non-<see cref="T:Amber.Success`1"/> results will be dropped.</returns>
        </member>
        <member name="M:Amber.Result.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Amber.Result{``1}})">
            <summary>
            Convert all elements in this sequence to a result of type <typeparamref name="B"/>, and then return an enumerable
            of the values of only the <see cref="T:Amber.Success`1"/>es.
            </summary>
            <typeparam name="A">The type of items in this enumerable.</typeparam>
            <typeparam name="B">The type of items in the result enumerable.</typeparam>
            <param name="this">The extended enumerable.</param>
            <param name="func">A function that will take each item from this enumerable and return a <see cref="T:Amber.Result`1"/>
            representing an operation on that item.</param>
            <returns>An enumeration of values taken from only successful results returned via the given <paramref name="func"/>.</returns>
        </member>
        <member name="M:Amber.Result.SelectMany``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Amber.Result{``1}},System.Func{``0,``1,``2})">
            <summary>
            Binds each value in this enumerable to the result returned by passing that value to the given <paramref name="func"/>;
            and if that func returns a <see cref="T:Amber.Success`1"/>, passes both values to the given <paramref name="selector"/>.
            Each result returned by the selector is then accrued in to a new enumerable, which is returned.
            </summary>
            <typeparam name="A">The type of object this enumerable contains.</typeparam>
            <typeparam name="B">The type of object returned by the operation that the given <paramref name="func"/> encapsulates.</typeparam>
            <typeparam name="C">The final type of object that the <paramref name="selector"/> func returns.</typeparam>
            <param name="this">The extended enumerable.</param>
            <param name="func">A function that takes each object in this enumerable, and generates a new
            result that potentially returns a value of type <typeparamref name="B"/>.</param>
            <param name="selector">A function that takes each object in this enumerable and the result returned by the <paramref name="func"/>,
            and returns a third value.</param>
            <returns>A collection containing all the values returned by the <paramref name="selector"/> func.</returns>
        </member>
        <member name="M:Amber.Result.SelectMany``2(System.IObservable{``0},System.Func{``0,Amber.Result{``1}})">
            <summary>
            Convert all elements in this sequence to a result of type <typeparamref name="B"/>, and then filters out everything except
            the <see cref="T:Amber.Success`1"/>es.
            </summary>
            <typeparam name="A">The type of items in this observable.</typeparam>
            <typeparam name="B">The type of items in the result observable.</typeparam>
            <param name="this">The extended observable.</param>
            <param name="func">A function that will take each item from this observable and return a <see cref="T:Amber.Result`1"/>
            representing an operation on that item.</param>
            <returns>An observable of values taken from only successful results returned via the given <paramref name="func"/>.</returns>
        </member>
        <member name="M:Amber.Result.SelectMany``3(System.IObservable{``0},System.Func{``0,Amber.Result{``1}},System.Func{``0,``1,Amber.Result{``2}})">
            <summary>
            Takes every item from this observable, and passes it to the given <paramref name="func"/>. If the <paramref name="func"/> returns
            a <see cref="T:Amber.Success`1"/>, both the original item and the result encapsulated by that success are passed to the
            <paramref name="selector"/>. If the selector then also returns a <see cref="T:Amber.Success`1"/>; the result from that success
            is pushed to the returned observable.
            </summary>
            <typeparam name="A">The item type of this collection.</typeparam>
            <typeparam name="B">The item type of successful values returned by the <paramref name="func"/> results.</typeparam>
            <typeparam name="C">The item type of successful values returned by the <paramref name="selector"/> func.</typeparam>
            <param name="sequence">The extended enumerable.</param>
            <param name="func">The function to which every element in this observable will be passed.</param>
            <param name="selector">The selector func that selects between each original value in this observable and the
            successful value returned by the <paramref name="func"/> (only when the func returns <see cref="T:Amber.Success`1"/>es).</param>
            <returns>An observable of successfully selected objects.</returns>
        </member>
        <member name="M:Amber.Result.SelectMany``2(System.IObservable{Amber.Result{``0}},System.Func{``0,Amber.Result{``1}})">
            <summary>
            Convert all elements in this sequence to a result of type <typeparamref name="B"/>.
            </summary>
            <typeparam name="A">The type of items in this observable.</typeparam>
            <typeparam name="B">The type of items in the result observable.</typeparam>
            <param name="this">The extended observable.</param>
            <param name="func">A function that will take each item from this observable and return a <see cref="T:Amber.Result`1"/>
            representing an operation on that item.</param>
            <returns>An observable of results according to values passed in to the given <paramref name="func"/>.</returns>
        </member>
        <member name="M:Amber.Result.SelectMany``3(System.IObservable{Amber.Result{``0}},System.Func{``0,Amber.Result{``1}},System.Func{``0,``1,``2})">
            <summary>
            Binds each value in this observable to the result returned by passing that value to the given <paramref name="func"/>;
            and if that func returns a <see cref="T:Amber.Success`1"/>, passes both values to the given <paramref name="selector"/>.
            Each result returned by the selector is then accrued in to a new observable, which is returned.
            </summary>
            <typeparam name="A">The type of object this observable contains.</typeparam>
            <typeparam name="B">The type of object returned by the operation that the given <paramref name="func"/> encapsulates.</typeparam>
            <typeparam name="C">The final type of object that the <paramref name="selector"/> func returns.</typeparam>
            <param name="this">The extended observable.</param>
            <param name="func">A function that takes each object in this observable, and generates a new
            result that potentially returns a value of type <typeparamref name="B"/>.</param>
            <param name="selector">A function that takes each object in this observable and the result returned by the <paramref name="func"/>,
            and returns a third value.</param>
            <returns>An observable containing all the values returned by the <paramref name="selector"/> func.</returns>
        </member>
        <member name="M:Amber.Result.Successes``1(System.IObservable{Amber.Result{``0}})">
            <summary>
            Filters this observable, allowing only <see cref="T:Amber.Success`1"/>es to pass through.
            </summary>
            <typeparam name="T">The inner type.</typeparam>
            <param name="this">The extended observable.</param>
            <returns>A new observable of only the successful results' values.</returns>
        </member>
        <member name="T:Amber.Hertz">
            <summary>
            Represents a frequency as instances-per-second.
            </summary>
        </member>
        <member name="F:Amber.Hertz.UnitSymbol">
            <summary>
            The unit symbol for this type (appended to the <see cref="F:Amber.Hertz.Count"/> value returned from <see cref="M:Amber.Hertz.ToString"/>).
            </summary>
        </member>
        <member name="F:Amber.Hertz.Zero">
            <summary>
            Static readonly value representing a <see cref="F:Amber.Hertz.Count"/> of <c>0d</c>.
            </summary>
        </member>
        <member name="F:Amber.Hertz.One">
            <summary>
            Static readonly value representing a <see cref="F:Amber.Hertz.Count"/> of <c>1d</c>.
            </summary>
        </member>
        <member name="F:Amber.Hertz.Count">
            <summary>
            The actual number of Hertz this instance represents.
            </summary>
        </member>
        <member name="M:Amber.Hertz.#ctor(System.Double)">
            <summary>
            Create a new instance whose <see cref="F:Amber.Hertz.Count"/> is equal to the parameter <paramref name="count"/>.
            </summary>
            <param name="count">The <see cref="F:Amber.Hertz.Count"/> for this instance.</param>
        </member>
        <member name="M:Amber.Hertz.Parse(System.String)">
            <summary>
            Parse the given <paramref name="input"/> string that represents a numeric value.
            </summary>
            <param name="input">The input string. Must contain nothing except either a number, or a number followed by the
            <see cref="F:Amber.Hertz.UnitSymbol"/> for this type.</param>
            <returns>The parsed input value.</returns>
        </member>
        <member name="M:Amber.Hertz.#ctor(Amber.Rate)">
            <summary>
            Create a new instance whose <see cref="F:Amber.Hertz.Count"/> is equal to the value represented by one second
            of the given <paramref name="rate"/>.
            </summary>
            <param name="rate">The rate to use to create this instance.</param>
        </member>
        <member name="M:Amber.Hertz.Plus(Amber.Hertz)">
            <summary>
            Add the <paramref name="operand"/>'s <see cref="F:Amber.Hertz.Count"/> to this instance's <see cref="F:Amber.Hertz.Count"/>.
            </summary>
            <param name="operand">The other value to add.</param>
            <returns>A new <see cref="T:Amber.Hertz"/> instance that is the sum of this and the <paramref name="operand"/>.</returns>
        </member>
        <member name="M:Amber.Hertz.Minus(Amber.Hertz)">
            <summary>
            Subtract the <paramref name="operand"/>'s <see cref="F:Amber.Hertz.Count"/> from this instance's <see cref="F:Amber.Hertz.Count"/>.
            </summary>
            <param name="operand">The value to subtract from this one.</param>
            <returns>A new <see cref="T:Amber.Hertz"/> instance that is the difference of <paramref name="operand"/> from this.</returns>
        </member>
        <member name="M:Amber.Hertz.MultipliedBy(System.Double)">
            <summary>
            Multiply this instance by the scalar <paramref name="operand"/>.
            </summary>
            <param name="operand">The number to multiply by.</param>
            <returns>A new <see cref="T:Amber.Hertz"/> instance that represents this instance's <see cref="F:Amber.Hertz.Count"/> multiplied
            by <paramref name="operand"/>.</returns>
        </member>
        <member name="M:Amber.Hertz.DividedBy(System.Double)">
            <summary>
            Divide this instance by the scalar <paramref name="operand"/>.
            </summary>
            <param name="operand">The number to divide by.</param>
            <returns>A new <see cref="T:Amber.Hertz"/> instance that represents this instance's <see cref="F:Amber.Hertz.Count"/> divided
            by <paramref name="operand"/>.</returns>
        </member>
        <member name="M:Amber.Hertz.ToRate">
            <summary>
            Convert this <see cref="T:Amber.Hertz"/> instance to a <see cref="T:Amber.Rate"/> that represents the same instance-per-second count.
            </summary>
            <returns>The equivalent of calling <see cref="M:Amber.Rate.PerSecond(System.Double)"/> with this instance's <see cref="F:Amber.Hertz.Count"/> as the input
            parameter.</returns>
        </member>
        <member name="M:Amber.Hertz.CalculateAngularVelocityAsEnergy(System.Double)">
            <summary>
            Calculate the kinetic energy represented by a flywheel that is rotating with this frequency and the given
            <paramref name="momentOfInertia"/>.
            </summary>
            <param name="momentOfInertia">The moment of inertia.</param>
            <returns>A new <see cref="T:Amber.Joules"/> instance representing the stored kinetic energy.</returns>
        </member>
        <member name="M:Amber.Hertz.op_Addition(Amber.Hertz,Amber.Hertz)">
            <summary>
            See <see cref="M:Amber.Hertz.Plus(Amber.Hertz)"/>.
            </summary>
        </member>
        <member name="M:Amber.Hertz.op_Subtraction(Amber.Hertz,Amber.Hertz)">
            <summary>
            See <see cref="M:Amber.Hertz.Minus(Amber.Hertz)"/>.
            </summary>
        </member>
        <member name="M:Amber.Hertz.op_Multiply(Amber.Hertz,System.Double)">
            <summary>
            See <see cref="M:Amber.Hertz.MultipliedBy(System.Double)"/>.
            </summary>
        </member>
        <member name="M:Amber.Hertz.op_Multiply(System.Double,Amber.Hertz)">
            <summary>
            See <see cref="M:Amber.Hertz.MultipliedBy(System.Double)"/>.
            </summary>
        </member>
        <member name="M:Amber.Hertz.op_Division(Amber.Hertz,System.Double)">
            <summary>
            See <see cref="M:Amber.Hertz.DividedBy(System.Double)"/>.
            </summary>
        </member>
        <member name="M:Amber.Hertz.op_UnaryNegation(Amber.Hertz)">
            <summary>
            Reverses this instance's <see cref="F:Amber.Hertz.Count"/> (same outcome as multiplying this value by -1).
            </summary>
        </member>
        <member name="M:Amber.Hertz.op_Explicit(System.Double)~Amber.Hertz">
            <summary>
            Convert the <paramref name="operand"/> to a <see cref="T:Amber.Hertz"/> instance with the same <see cref="F:Amber.Hertz.Count"/>.
            </summary>
            <param name="operand">The <see cref="F:Amber.Hertz.Count"/> for the new instance.</param>
        </member>
        <member name="M:Amber.Hertz.op_Explicit(Amber.Hertz)~System.Double">
            <summary>
            Convert the <paramref name="operand"/> to a <see cref="T:System.Double"/> that is
            identical to the <paramref name="operand"/>'s <see cref="F:Amber.Hertz.Count"/>.
            </summary>
            <param name="operand">The <see cref="T:Amber.Amps"/> instance to convert.</param>
        </member>
        <member name="M:Amber.Hertz.op_Implicit(Amber.Hertz)~Amber.Rate">
            <summary>
            See <see cref="M:Amber.Hertz.ToRate"/>.
            </summary>
        </member>
        <member name="M:Amber.Hertz.op_Implicit(Amber.Rate)~Amber.Hertz">
            <summary>
            See <see cref="M:Amber.Hertz.#ctor(Amber.Rate)"/>.
            </summary>
        </member>
        <member name="M:Amber.Hertz.ToString">
            <inheritdoc />
        </member>
        <member name="M:Amber.Hertz.Equals(Amber.Hertz)">
            <inheritdoc />
        </member>
        <member name="M:Amber.Hertz.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Amber.Hertz.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Amber.Hertz.op_Equality(Amber.Hertz,Amber.Hertz)">
            <summary>
            <see cref="M:Amber.Hertz.Equals(Amber.Hertz)"/>.
            </summary>
        </member>
        <member name="M:Amber.Hertz.op_Inequality(Amber.Hertz,Amber.Hertz)">
            <summary>
            <see cref="M:Amber.Hertz.Equals(Amber.Hertz)"/>.
            </summary>
        </member>
        <member name="M:Amber.Hertz.CompareTo(Amber.Hertz)">
            <inheritdoc />
        </member>
        <member name="M:Amber.Hertz.op_GreaterThan(Amber.Hertz,Amber.Hertz)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.Hertz.Count"/>
            is greater than <paramref name="rhs"/>.<see cref="F:Amber.Hertz.Count"/>.</returns>
        </member>
        <member name="M:Amber.Hertz.op_LessThan(Amber.Hertz,Amber.Hertz)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.Hertz.Count"/>
            is less than <paramref name="rhs"/>.<see cref="F:Amber.Hertz.Count"/>.</returns>
        </member>
        <member name="M:Amber.Hertz.op_GreaterThanOrEqual(Amber.Hertz,Amber.Hertz)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.Hertz.Count"/>
            is greater than or equal to <paramref name="rhs"/>.<see cref="F:Amber.Hertz.Count"/>.</returns>
        </member>
        <member name="M:Amber.Hertz.op_LessThanOrEqual(Amber.Hertz,Amber.Hertz)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.Hertz.Count"/>
            is less than or equal to <paramref name="rhs"/>.<see cref="F:Amber.Hertz.Count"/>.</returns>
        </member>
        <member name="T:Amber.Millitorrs">
            <summary>
            Represents a number of Millitorrs.
            </summary>
        </member>
        <member name="F:Amber.Millitorrs.UnitSymbol">
            <summary>
            The unit symbol for this type (appended to the <see cref="F:Amber.Millitorrs.Count"/> value returned from <see cref="M:Amber.Millitorrs.ToString"/>).
            </summary>
        </member>
        <member name="F:Amber.Millitorrs.Zero">
            <summary>
            Static readonly value representing a <see cref="F:Amber.Millitorrs.Count"/> of <c>0d</c>.
            </summary>
        </member>
        <member name="F:Amber.Millitorrs.One">
            <summary>
            Static readonly value representing a <see cref="F:Amber.Millitorrs.Count"/> of <c>1d</c>.
            </summary>
        </member>
        <member name="F:Amber.Millitorrs.Count">
            <summary>
            The actual number of millitorrs this instance represents.
            </summary>
        </member>
        <member name="M:Amber.Millitorrs.#ctor(System.Double)">
            <summary>
            Create a new instance whose <see cref="F:Amber.Millitorrs.Count"/> is equal to the parameter <paramref name="count"/>.
            </summary>
            <param name="count">The <see cref="F:Amber.Millitorrs.Count"/> for this instance.</param>
        </member>
        <member name="M:Amber.Millitorrs.Parse(System.String)">
            <summary>
            Parse the given <paramref name="input"/> string that represents a numeric value.
            </summary>
            <param name="input">The input string. Must contain nothing except either a number, or a number followed by the
            <see cref="F:Amber.Millitorrs.UnitSymbol"/> for this type.</param>
            <returns>The parsed input value.</returns>
        </member>
        <member name="M:Amber.Millitorrs.Plus(Amber.Millitorrs)">
            <summary>
            Add the <paramref name="operand"/>'s <see cref="F:Amber.Millitorrs.Count"/> to this instance's <see cref="F:Amber.Millitorrs.Count"/>.
            </summary>
            <param name="operand">The other value to add.</param>
            <returns>A new <see cref="T:Amber.Millitorrs"/> instance that is the sum of this and the <paramref name="operand"/>.</returns>
        </member>
        <member name="M:Amber.Millitorrs.Minus(Amber.Millitorrs)">
            <summary>
            Subtract the <paramref name="operand"/>'s <see cref="F:Amber.Millitorrs.Count"/> from this instance's <see cref="F:Amber.Millitorrs.Count"/>.
            </summary>
            <param name="operand">The value to subtract from this one.</param>
            <returns>A new <see cref="T:Amber.Millitorrs"/> instance that is the difference of <paramref name="operand"/> from this.</returns>
        </member>
        <member name="M:Amber.Millitorrs.MultipliedBy(System.Double)">
            <summary>
            Multiply this instance by the scalar <paramref name="operand"/>.
            </summary>
            <param name="operand">The number to multiply by.</param>
            <returns>A new <see cref="T:Amber.Millitorrs"/> instance that represents this instance's <see cref="F:Amber.Millitorrs.Count"/> multiplied
            by <paramref name="operand"/>.</returns>
        </member>
        <member name="M:Amber.Millitorrs.DividedBy(System.Double)">
            <summary>
            Divide this instance by the scalar <paramref name="operand"/>.
            </summary>
            <param name="operand">The number to divide by.</param>
            <returns>A new <see cref="T:Amber.Millitorrs"/> instance that represents this instance's <see cref="F:Amber.Millitorrs.Count"/> divided
            by <paramref name="operand"/>.</returns>
        </member>
        <member name="M:Amber.Millitorrs.op_Addition(Amber.Millitorrs,Amber.Millitorrs)">
            <summary>
            See <see cref="M:Amber.Millitorrs.Plus(Amber.Millitorrs)"/>.
            </summary>
        </member>
        <member name="M:Amber.Millitorrs.op_Subtraction(Amber.Millitorrs,Amber.Millitorrs)">
            <summary>
            See <see cref="M:Amber.Millitorrs.Minus(Amber.Millitorrs)"/>.
            </summary>
        </member>
        <member name="M:Amber.Millitorrs.op_Multiply(Amber.Millitorrs,System.Double)">
            <summary>
            See <see cref="M:Amber.Millitorrs.MultipliedBy(System.Double)"/>.
            </summary>
        </member>
        <member name="M:Amber.Millitorrs.op_Multiply(System.Double,Amber.Millitorrs)">
            <summary>
            See <see cref="M:Amber.Millitorrs.MultipliedBy(System.Double)"/>.
            </summary>
        </member>
        <member name="M:Amber.Millitorrs.op_Division(Amber.Millitorrs,System.Double)">
            <summary>
            See <see cref="M:Amber.Millitorrs.DividedBy(System.Double)"/>.
            </summary>
        </member>
        <member name="M:Amber.Millitorrs.op_UnaryNegation(Amber.Millitorrs)">
            <summary>
            Reverses this instance's <see cref="F:Amber.Millitorrs.Count"/> (same outcome as multiplying this value by -1).
            </summary>
        </member>
        <member name="M:Amber.Millitorrs.op_Explicit(System.Double)~Amber.Millitorrs">
            <summary>
            Convert the <paramref name="operand"/> to a <see cref="T:Amber.Millitorrs"/> instance with the same <see cref="F:Amber.Millitorrs.Count"/>.
            </summary>
            <param name="operand">The <see cref="F:Amber.Millitorrs.Count"/> for the new instance.</param>
        </member>
        <member name="M:Amber.Millitorrs.op_Explicit(Amber.Millitorrs)~System.Double">
            <summary>
            Convert the <paramref name="operand"/> to a <see cref="T:System.Double"/> that is
            identical to the <paramref name="operand"/>'s <see cref="F:Amber.Millitorrs.Count"/>.
            </summary>
            <param name="operand">The <see cref="T:Amber.Millitorrs"/> instance to convert.</param>
        </member>
        <member name="M:Amber.Millitorrs.ToString">
            <inheritdoc />
        </member>
        <member name="M:Amber.Millitorrs.Equals(Amber.Millitorrs)">
            <inheritdoc />
        </member>
        <member name="M:Amber.Millitorrs.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Amber.Millitorrs.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Amber.Millitorrs.op_Equality(Amber.Millitorrs,Amber.Millitorrs)">
            <summary>
            See <see cref="M:Amber.Millitorrs.Equals(Amber.Millitorrs)"/>.
            </summary>
        </member>
        <member name="M:Amber.Millitorrs.op_Inequality(Amber.Millitorrs,Amber.Millitorrs)">
            <summary>
            See <see cref="M:Amber.Millitorrs.Equals(Amber.Millitorrs)"/>.
            </summary>
        </member>
        <member name="M:Amber.Millitorrs.CompareTo(Amber.Millitorrs)">
            <inheritdoc />
        </member>
        <member name="M:Amber.Millitorrs.op_GreaterThan(Amber.Millitorrs,Amber.Millitorrs)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.Millitorrs.Count"/>
            is greater than <paramref name="rhs"/>.<see cref="F:Amber.Millitorrs.Count"/>.</returns>
        </member>
        <member name="M:Amber.Millitorrs.op_LessThan(Amber.Millitorrs,Amber.Millitorrs)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.Millitorrs.Count"/>
            is less than <paramref name="rhs"/>.<see cref="F:Amber.Millitorrs.Count"/>.</returns>
        </member>
        <member name="M:Amber.Millitorrs.op_GreaterThanOrEqual(Amber.Millitorrs,Amber.Millitorrs)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.Millitorrs.Count"/>
            is greater than or equal to <paramref name="rhs"/>.<see cref="F:Amber.Millitorrs.Count"/>.</returns>
        </member>
        <member name="M:Amber.Millitorrs.op_LessThanOrEqual(Amber.Millitorrs,Amber.Millitorrs)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.Millitorrs.Count"/>
            is less than or equal to <paramref name="rhs"/>.<see cref="F:Amber.Millitorrs.Count"/>.</returns>
        </member>
        <member name="T:Amber.Grams">
            <summary>
            Represents a number of Grams.
            </summary>
        </member>
        <member name="F:Amber.Grams.UnitSymbol">
            <summary>
            The unit symbol for this type (appended to the <see cref="F:Amber.Grams.Count"/> value returned from <see cref="M:Amber.Grams.ToString"/>).
            </summary>
        </member>
        <member name="F:Amber.Grams.Zero">
            <summary>
            Static readonly value representing a <see cref="F:Amber.Grams.Count"/> of <c>0d</c>.
            </summary>
        </member>
        <member name="F:Amber.Grams.One">
            <summary>
            Static readonly value representing a <see cref="F:Amber.Grams.Count"/> of <c>1d</c>.
            </summary>
        </member>
        <member name="F:Amber.Grams.GramsInOnePound">
            <summary>
            Conversion factor from <see cref="T:Amber.Grams"/> to <see cref="T:Amber.Pounds"/>.
            </summary>
        </member>
        <member name="F:Amber.Grams.Count">
            <summary>
            The actual number of Grams this instance represents.
            </summary>
        </member>
        <member name="M:Amber.Grams.#ctor(System.Double)">
            <summary>
            Create a new instance whose <see cref="F:Amber.Grams.Count"/> is equal to the parameter <paramref name="count"/>.
            </summary>
            <param name="count">The <see cref="F:Amber.Grams.Count"/> for this instance.</param>
        </member>
        <member name="M:Amber.Grams.Parse(System.String)">
            <summary>
            Parse the given <paramref name="input"/> string that represents a numeric value.
            </summary>
            <param name="input">The input string. Must contain nothing except either a number, or a number followed by the
            <see cref="F:Amber.Grams.UnitSymbol"/> for this type.</param>
            <returns>The parsed input value.</returns>
        </member>
        <member name="M:Amber.Grams.Plus(Amber.Grams)">
            <summary>
            Add the <paramref name="operand"/>'s <see cref="F:Amber.Grams.Count"/> to this instance's <see cref="F:Amber.Grams.Count"/>.
            </summary>
            <param name="operand">The other value to add.</param>
            <returns>A new <see cref="T:Amber.Grams"/> instance that is the sum of this and the <paramref name="operand"/>.</returns>
        </member>
        <member name="M:Amber.Grams.Minus(Amber.Grams)">
            <summary>
            Subtract the <paramref name="operand"/>'s <see cref="F:Amber.Grams.Count"/> from this instance's <see cref="F:Amber.Grams.Count"/>.
            </summary>
            <param name="operand">The value to subtract from this one.</param>
            <returns>A new <see cref="T:Amber.Grams"/> instance that is the difference of <paramref name="operand"/> from this.</returns>
        </member>
        <member name="M:Amber.Grams.MultipliedBy(System.Double)">
            <summary>
            Multiply this instance by the scalar <paramref name="operand"/>.
            </summary>
            <param name="operand">The number to multiply by.</param>
            <returns>A new <see cref="T:Amber.Grams"/> instance that represents this instance's <see cref="F:Amber.Grams.Count"/> multiplied
            by <paramref name="operand"/>.</returns>
        </member>
        <member name="M:Amber.Grams.DividedBy(System.Double)">
            <summary>
            Divide this instance by the scalar <paramref name="operand"/>.
            </summary>
            <param name="operand">The number to divide by.</param>
            <returns>A new <see cref="T:Amber.Grams"/> instance that represents this instance's <see cref="F:Amber.Grams.Count"/> divided
            by <paramref name="operand"/>.</returns>
        </member>
        <member name="M:Amber.Grams.ToPounds">
            <summary>
            Convert this <see cref="T:Amber.Grams"/> instance to the equivalent value in <see cref="T:Amber.Pounds"/>.
            </summary>
            <returns>A new <see cref="T:Amber.Pounds"/> instance whose <see cref="F:Amber.Pounds.Count"/> is set according
            to the <see cref="F:Amber.Grams.GramsInOnePound"/> conversion.</returns>
        </member>
        <member name="M:Amber.Grams.op_Addition(Amber.Grams,Amber.Grams)">
            <summary>
            See <see cref="M:Amber.Grams.Plus(Amber.Grams)"/>.
            </summary>
        </member>
        <member name="M:Amber.Grams.op_Subtraction(Amber.Grams,Amber.Grams)">
            <summary>
            See <see cref="M:Amber.Grams.Minus(Amber.Grams)"/>.
            </summary>
        </member>
        <member name="M:Amber.Grams.op_Multiply(Amber.Grams,System.Double)">
            <summary>
            See <see cref="M:Amber.Grams.MultipliedBy(System.Double)"/>.
            </summary>
        </member>
        <member name="M:Amber.Grams.op_Multiply(System.Double,Amber.Grams)">
            <summary>
            See <see cref="M:Amber.Grams.MultipliedBy(System.Double)"/>.
            </summary>
        </member>
        <member name="M:Amber.Grams.op_Division(Amber.Grams,System.Double)">
            <summary>
            See <see cref="M:Amber.Grams.DividedBy(System.Double)"/>.
            </summary>
        </member>
        <member name="M:Amber.Grams.op_UnaryNegation(Amber.Grams)">
            <summary>
            Reverses this instance's <see cref="F:Amber.Grams.Count"/> (same outcome as multiplying this value by -1).
            </summary>
        </member>
        <member name="M:Amber.Grams.op_Explicit(System.Double)~Amber.Grams">
            <summary>
            Convert the <paramref name="operand"/> to a <see cref="T:Amber.Grams"/> instance with the same <see cref="F:Amber.Grams.Count"/>.
            </summary>
            <param name="operand">The <see cref="F:Amber.Grams.Count"/> for the new instance.</param>
        </member>
        <member name="M:Amber.Grams.op_Explicit(Amber.Grams)~System.Double">
            <summary>
            Convert the <paramref name="operand"/> to a <see cref="T:System.Double"/> that is
            identical to the <paramref name="operand"/>'s <see cref="F:Amber.Grams.Count"/>.
            </summary>
            <param name="operand">The <see cref="T:Amber.Grams"/> instance to convert.</param>
        </member>
        <member name="M:Amber.Grams.op_Implicit(Amber.Grams)~Amber.Pounds">
            <summary>
            <see cref="M:Amber.Grams.ToPounds"/>.
            </summary>
        </member>
        <member name="M:Amber.Grams.ToString">
            <inheritdoc />
        </member>
        <member name="M:Amber.Grams.Equals(Amber.Grams)">
            <inheritdoc />
        </member>
        <member name="M:Amber.Grams.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Amber.Grams.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Amber.Grams.op_Equality(Amber.Grams,Amber.Grams)">
            <summary>
            <see cref="M:Amber.Grams.Equals(Amber.Grams)"/>/.
            </summary>
        </member>
        <member name="M:Amber.Grams.op_Inequality(Amber.Grams,Amber.Grams)">
            <summary>
            <see cref="M:Amber.Grams.Equals(Amber.Grams)"/>/.
            </summary>
        </member>
        <member name="M:Amber.Grams.CompareTo(Amber.Grams)">
            <inheritdoc />
        </member>
        <member name="M:Amber.Grams.op_GreaterThan(Amber.Grams,Amber.Grams)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.Grams.Count"/>
            is greater than <paramref name="rhs"/>.<see cref="F:Amber.Grams.Count"/>.</returns>
        </member>
        <member name="M:Amber.Grams.op_LessThan(Amber.Grams,Amber.Grams)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.Grams.Count"/>
            is less than <paramref name="rhs"/>.<see cref="F:Amber.Grams.Count"/>.</returns>
        </member>
        <member name="M:Amber.Grams.op_GreaterThanOrEqual(Amber.Grams,Amber.Grams)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.Grams.Count"/>
            is greater than or equal to <paramref name="rhs"/>.<see cref="F:Amber.Grams.Count"/>.</returns>
        </member>
        <member name="M:Amber.Grams.op_LessThanOrEqual(Amber.Grams,Amber.Grams)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.Grams.Count"/>
            is less than or equal to <paramref name="rhs"/>.<see cref="F:Amber.Grams.Count"/>.</returns>
        </member>
        <member name="T:Amber.Pounds">
            <summary>
            Represents a number of Pounds (weight).
            </summary>
        </member>
        <member name="F:Amber.Pounds.UnitSymbol">
            <summary>
            The unit symbol for this type (appended to the <see cref="F:Amber.Pounds.Count"/> value returned from <see cref="M:Amber.Pounds.ToString"/>).
            </summary>
        </member>
        <member name="F:Amber.Pounds.Zero">
            <summary>
            Static readonly value representing a <see cref="F:Amber.Pounds.Count"/> of <c>0d</c>.
            </summary>
        </member>
        <member name="F:Amber.Pounds.One">
            <summary>
            Static readonly value representing a <see cref="F:Amber.Pounds.Count"/> of <c>1d</c>.
            </summary>
        </member>
        <member name="F:Amber.Pounds.Count">
            <summary>
            The actual number of Pounds this instance represents.
            </summary>
        </member>
        <member name="M:Amber.Pounds.#ctor(System.Double)">
            <summary>
            Create a new instance whose <see cref="F:Amber.Pounds.Count"/> is equal to the parameter <paramref name="count"/>.
            </summary>
            <param name="count">The <see cref="F:Amber.Pounds.Count"/> for this instance.</param>
        </member>
        <member name="M:Amber.Pounds.Parse(System.String)">
            <summary>
            Parse the given <paramref name="input"/> string that represents a numeric value.
            </summary>
            <param name="input">The input string. Must contain nothing except either a number, or a number followed by the
            <see cref="F:Amber.Pounds.UnitSymbol"/> for this type.</param>
            <returns>The parsed input value.</returns>
        </member>
        <member name="M:Amber.Pounds.Plus(Amber.Pounds)">
            <summary>
            Add the <paramref name="operand"/>'s <see cref="F:Amber.Pounds.Count"/> to this instance's <see cref="F:Amber.Pounds.Count"/>.
            </summary>
            <param name="operand">The other value to add.</param>
            <returns>A new <see cref="T:Amber.Pounds"/> instance that is the sum of this and the <paramref name="operand"/>.</returns>
        </member>
        <member name="M:Amber.Pounds.Minus(Amber.Pounds)">
            <summary>
            Subtract the <paramref name="operand"/>'s <see cref="F:Amber.Pounds.Count"/> from this instance's <see cref="F:Amber.Pounds.Count"/>.
            </summary>
            <param name="operand">The value to subtract from this one.</param>
            <returns>A new <see cref="T:Amber.Pounds"/> instance that is the difference of <paramref name="operand"/> from this.</returns>
        </member>
        <member name="M:Amber.Pounds.MultipliedBy(System.Double)">
            <summary>
            Multiply this instance by the scalar <paramref name="operand"/>.
            </summary>
            <param name="operand">The number to multiply by.</param>
            <returns>A new <see cref="T:Amber.Pounds"/> instance that represents this instance's <see cref="F:Amber.Pounds.Count"/> multiplied
            by <paramref name="operand"/>.</returns>
        </member>
        <member name="M:Amber.Pounds.DividedBy(System.Double)">
            <summary>
            Divide this instance by the scalar <paramref name="operand"/>.
            </summary>
            <param name="operand">The number to divide by.</param>
            <returns>A new <see cref="T:Amber.Pounds"/> instance that represents this instance's <see cref="F:Amber.Pounds.Count"/> divided
            by <paramref name="operand"/>.</returns>
        </member>
        <member name="M:Amber.Pounds.ToGrams">
            <summary>
            Convert this <see cref="T:Amber.Pounds"/> instance to the equivalent value in <see cref="T:Amber.Grams"/>.
            </summary>
            <returns>A new <see cref="T:Amber.Grams"/> instance whose <see cref="F:Amber.Grams.Count"/> is set according
            to the <see cref="F:Amber.Grams.GramsInOnePound"/> conversion.</returns>
        </member>
        <member name="M:Amber.Pounds.op_Addition(Amber.Pounds,Amber.Pounds)">
            <summary>
            See <see cref="M:Amber.Pounds.Plus(Amber.Pounds)"/>.
            </summary>
        </member>
        <member name="M:Amber.Pounds.op_Subtraction(Amber.Pounds,Amber.Pounds)">
            <summary>
            See <see cref="M:Amber.Pounds.Minus(Amber.Pounds)"/>.
            </summary>
        </member>
        <member name="M:Amber.Pounds.op_Multiply(Amber.Pounds,System.Double)">
            <summary>
            See <see cref="M:Amber.Pounds.MultipliedBy(System.Double)"/>.
            </summary>
        </member>
        <member name="M:Amber.Pounds.op_Multiply(System.Double,Amber.Pounds)">
            <summary>
            See <see cref="M:Amber.Pounds.MultipliedBy(System.Double)"/>.
            </summary>
        </member>
        <member name="M:Amber.Pounds.op_Division(Amber.Pounds,System.Double)">
            <summary>
            See <see cref="M:Amber.Pounds.DividedBy(System.Double)"/>.
            </summary>
        </member>
        <member name="M:Amber.Pounds.op_UnaryNegation(Amber.Pounds)">
            <summary>
            Reverses this instance's <see cref="F:Amber.Pounds.Count"/> (same outcome as multiplying this value by -1).
            </summary>
        </member>
        <member name="M:Amber.Pounds.op_Explicit(System.Double)~Amber.Pounds">
            <summary>
            Convert the <paramref name="operand"/> to a <see cref="T:Amber.Pounds"/> instance with the same <see cref="F:Amber.Pounds.Count"/>.
            </summary>
            <param name="operand">The <see cref="F:Amber.Pounds.Count"/> for the new instance.</param>
        </member>
        <member name="M:Amber.Pounds.op_Explicit(Amber.Pounds)~System.Double">
            <summary>
            Convert the <paramref name="operand"/> to a <see cref="T:System.Double"/> that is
            identical to the <paramref name="operand"/>'s <see cref="F:Amber.Pounds.Count"/>.
            </summary>
            <param name="operand">The <see cref="T:Amber.Pounds"/> instance to convert.</param>
        </member>
        <member name="M:Amber.Pounds.op_Implicit(Amber.Pounds)~Amber.Grams">
            <summary>
            See <see cref="M:Amber.Pounds.ToGrams"/>.
            </summary>
        </member>
        <member name="M:Amber.Pounds.ToString">
            <inheritdoc />
        </member>
        <member name="M:Amber.Pounds.Equals(Amber.Pounds)">
            <inheritdoc />
        </member>
        <member name="M:Amber.Pounds.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Amber.Pounds.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Amber.Pounds.op_Equality(Amber.Pounds,Amber.Pounds)">
            <summary>
            <see cref="M:Amber.Pounds.Equals(Amber.Pounds)"/>.
            </summary>
        </member>
        <member name="M:Amber.Pounds.op_Inequality(Amber.Pounds,Amber.Pounds)">
            <summary>
            <see cref="M:Amber.Pounds.Equals(Amber.Pounds)"/>.
            </summary>
        </member>
        <member name="M:Amber.Pounds.CompareTo(Amber.Pounds)">
            <inheritdoc />
        </member>
        <member name="M:Amber.Pounds.op_GreaterThan(Amber.Pounds,Amber.Pounds)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.Pounds.Count"/>
            is greater than <paramref name="rhs"/>.<see cref="F:Amber.Pounds.Count"/>.</returns>
        </member>
        <member name="M:Amber.Pounds.op_LessThan(Amber.Pounds,Amber.Pounds)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.Pounds.Count"/>
            is less than <paramref name="rhs"/>.<see cref="F:Amber.Pounds.Count"/>.</returns>
        </member>
        <member name="M:Amber.Pounds.op_GreaterThanOrEqual(Amber.Pounds,Amber.Pounds)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.Pounds.Count"/>
            is greater than or equal to <paramref name="rhs"/>.<see cref="F:Amber.Pounds.Count"/>.</returns>
        </member>
        <member name="M:Amber.Pounds.op_LessThanOrEqual(Amber.Pounds,Amber.Pounds)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.Pounds.Count"/>
            is less than or equal to <paramref name="rhs"/>.<see cref="F:Amber.Pounds.Count"/>.</returns>
        </member>
        <member name="T:Amber.Volts">
            <summary>
            Represents a number of Volts.
            </summary>
        </member>
        <member name="F:Amber.Volts.UnitSymbol">
            <summary>
            The unit symbol for this type (appended to the <see cref="F:Amber.Volts.Count"/> value returned from <see cref="M:Amber.Volts.ToString"/>).
            </summary>
        </member>
        <member name="F:Amber.Volts.Zero">
            <summary>
            Static readonly value representing a <see cref="F:Amber.Volts.Count"/> of <c>0d</c>.
            </summary>
        </member>
        <member name="F:Amber.Volts.One">
            <summary>
            Static readonly value representing a <see cref="F:Amber.Volts.Count"/> of <c>1d</c>.
            </summary>
        </member>
        <member name="F:Amber.Volts.Count">
            <summary>
            The actual number of Volts this instance represents.
            </summary>
        </member>
        <member name="M:Amber.Volts.#ctor(System.Double)">
            <summary>
            Create a new instance whose <see cref="F:Amber.Volts.Count"/> is equal to the parameter <paramref name="count"/>.
            </summary>
            <param name="count">The <see cref="F:Amber.Volts.Count"/> for this instance.</param>
        </member>
        <member name="M:Amber.Volts.Parse(System.String)">
            <summary>
            Parse the given <paramref name="input"/> string that represents a numeric value.
            </summary>
            <param name="input">The input string. Must contain nothing except either a number, or a number followed by the
            <see cref="F:Amber.Volts.UnitSymbol"/> for this type.</param>
            <returns>The parsed input value.</returns>
        </member>
        <member name="M:Amber.Volts.Plus(Amber.Volts)">
            <summary>
            Add the <paramref name="operand"/>'s <see cref="F:Amber.Volts.Count"/> to this instance's <see cref="F:Amber.Volts.Count"/>.
            </summary>
            <param name="operand">The other value to add.</param>
            <returns>A new <see cref="T:Amber.Volts"/> instance that is the sum of this and the <paramref name="operand"/>.</returns>
        </member>
        <member name="M:Amber.Volts.Minus(Amber.Volts)">
            <summary>
            Subtract the <paramref name="operand"/>'s <see cref="F:Amber.Volts.Count"/> from this instance's <see cref="F:Amber.Volts.Count"/>.
            </summary>
            <param name="operand">The value to subtract from this one.</param>
            <returns>A new <see cref="T:Amber.Volts"/> instance that is the difference of <paramref name="operand"/> from this.</returns>
        </member>
        <member name="M:Amber.Volts.MultipliedBy(System.Double)">
            <summary>
            Multiply this instance by the scalar <paramref name="operand"/>.
            </summary>
            <param name="operand">The number to multiply by.</param>
            <returns>A new <see cref="T:Amber.Volts"/> instance that represents this instance's <see cref="F:Amber.Volts.Count"/> multiplied
            by <paramref name="operand"/>.</returns>
        </member>
        <member name="M:Amber.Volts.DividedBy(System.Double)">
            <summary>
            Divide this instance by the scalar <paramref name="operand"/>.
            </summary>
            <param name="operand">The number to divide by.</param>
            <returns>A new <see cref="T:Amber.Volts"/> instance that represents this instance's <see cref="F:Amber.Volts.Count"/> divided
            by <paramref name="operand"/>.</returns>
        </member>
        <member name="M:Amber.Volts.op_Addition(Amber.Volts,Amber.Volts)">
            <summary>
            See <see cref="M:Amber.Volts.Plus(Amber.Volts)"/>.
            </summary>
        </member>
        <member name="M:Amber.Volts.op_Subtraction(Amber.Volts,Amber.Volts)">
            <summary>
            See <see cref="M:Amber.Volts.Minus(Amber.Volts)"/>.
            </summary>
        </member>
        <member name="M:Amber.Volts.op_Multiply(Amber.Volts,System.Double)">
            <summary>
            See <see cref="M:Amber.Volts.MultipliedBy(System.Double)"/>.
            </summary>
        </member>
        <member name="M:Amber.Volts.op_Multiply(System.Double,Amber.Volts)">
            <summary>
            See <see cref="M:Amber.Volts.MultipliedBy(System.Double)"/>.
            </summary>
        </member>
        <member name="M:Amber.Volts.op_Division(Amber.Volts,System.Double)">
            <summary>
            See <see cref="M:Amber.Volts.DividedBy(System.Double)"/>.
            </summary>
        </member>
        <member name="M:Amber.Volts.op_UnaryNegation(Amber.Volts)">
            <summary>
            Reverses this instance's <see cref="F:Amber.Volts.Count"/> (same outcome as multiplying this value by -1).
            </summary>
        </member>
        <member name="M:Amber.Volts.op_Explicit(System.Double)~Amber.Volts">
            <summary>
            Convert the <paramref name="operand"/> to an <see cref="T:Amber.Volts"/> instance with the same <see cref="F:Amber.Volts.Count"/>.
            </summary>
            <param name="operand">The <see cref="F:Amber.Volts.Count"/> for the new instance.</param>
        </member>
        <member name="M:Amber.Volts.op_Explicit(Amber.Volts)~System.Double">
            <summary>
            Convert the <paramref name="operand"/> to a <see cref="T:System.Double"/> that is
            identical to the <paramref name="operand"/>'s <see cref="F:Amber.Volts.Count"/>.
            </summary>
            <param name="operand">The <see cref="T:Amber.Volts"/> instance to convert.</param>
        </member>
        <member name="M:Amber.Volts.ToString">
            <inheritdoc />
        </member>
        <member name="M:Amber.Volts.Equals(Amber.Volts)">
            <inheritdoc />
        </member>
        <member name="M:Amber.Volts.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Amber.Volts.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Amber.Volts.op_Equality(Amber.Volts,Amber.Volts)">
            <summary>
            <see cref="M:Amber.Volts.Equals(Amber.Volts)"/>.
            </summary>
        </member>
        <member name="M:Amber.Volts.op_Inequality(Amber.Volts,Amber.Volts)">
            <summary>
            <see cref="M:Amber.Volts.Equals(Amber.Volts)"/>.
            </summary>
        </member>
        <member name="M:Amber.Volts.CompareTo(Amber.Volts)">
            <inheritdoc />
        </member>
        <member name="M:Amber.Volts.op_GreaterThan(Amber.Volts,Amber.Volts)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.Volts.Count"/>
            is greater than <paramref name="rhs"/>.<see cref="F:Amber.Volts.Count"/>.</returns>
        </member>
        <member name="M:Amber.Volts.op_LessThan(Amber.Volts,Amber.Volts)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.Volts.Count"/>
            is less than <paramref name="rhs"/>.<see cref="F:Amber.Volts.Count"/>.</returns>
        </member>
        <member name="M:Amber.Volts.op_GreaterThanOrEqual(Amber.Volts,Amber.Volts)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.Volts.Count"/>
            is greater than or equal to <paramref name="rhs"/>.<see cref="F:Amber.Volts.Count"/>.</returns>
        </member>
        <member name="M:Amber.Volts.op_LessThanOrEqual(Amber.Volts,Amber.Volts)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.Volts.Count"/>
            is less than or equal to <paramref name="rhs"/>.<see cref="F:Amber.Volts.Count"/>.</returns>
        </member>
        <member name="T:Amber.Watts">
            <summary>
            Represents a number of Watts.
            </summary>
        </member>
        <member name="F:Amber.Watts.UnitSymbol">
            <summary>
            The unit symbol for this type (appended to the <see cref="F:Amber.Watts.Count"/> value returned from <see cref="M:Amber.Watts.ToString"/>).
            </summary>
        </member>
        <member name="F:Amber.Watts.Zero">
            <summary>
            Static readonly value representing a <see cref="F:Amber.Watts.Count"/> of <c>0d</c>.
            </summary>
        </member>
        <member name="F:Amber.Watts.One">
            <summary>
            Static readonly value representing a <see cref="F:Amber.Watts.Count"/> of <c>1d</c>.
            </summary>
        </member>
        <member name="F:Amber.Watts.Count">
            <summary>
            The actual number of Watts this instance represents.
            </summary>
        </member>
        <member name="M:Amber.Watts.#ctor(System.Double)">
            <summary>
            Create a new instance whose <see cref="F:Amber.Watts.Count"/> is equal to the parameter <paramref name="count"/>.
            </summary>
            <param name="count">The <see cref="F:Amber.Watts.Count"/> for this instance.</param>
        </member>
        <member name="M:Amber.Watts.Parse(System.String)">
            <summary>
            Parse the given <paramref name="input"/> string that represents a numeric value.
            </summary>
            <param name="input">The input string. Must contain nothing except either a number, or a number followed by the
            <see cref="F:Amber.Watts.UnitSymbol"/> for this type.</param>
            <returns>The parsed input value.</returns>
        </member>
        <member name="M:Amber.Watts.Plus(Amber.Watts)">
            <summary>
            Add the <paramref name="operand"/>'s <see cref="F:Amber.Watts.Count"/> to this instance's <see cref="F:Amber.Watts.Count"/>.
            </summary>
            <param name="operand">The other value to add.</param>
            <returns>A new <see cref="T:Amber.Watts"/> instance that is the sum of this and the <paramref name="operand"/>.</returns>
        </member>
        <member name="M:Amber.Watts.Minus(Amber.Watts)">
            <summary>
            Subtract the <paramref name="operand"/>'s <see cref="F:Amber.Watts.Count"/> from this instance's <see cref="F:Amber.Watts.Count"/>.
            </summary>
            <param name="operand">The value to subtract from this one.</param>
            <returns>A new <see cref="T:Amber.Watts"/> instance that is the difference of <paramref name="operand"/> from this.</returns>
        </member>
        <member name="M:Amber.Watts.MultipliedBy(System.Double)">
            <summary>
            Multiply this instance by the scalar <paramref name="operand"/>.
            </summary>
            <param name="operand">The number to multiply by.</param>
            <returns>A new <see cref="T:Amber.Watts"/> instance that represents this instance's <see cref="F:Amber.Watts.Count"/> multiplied
            by <paramref name="operand"/>.</returns>
        </member>
        <member name="M:Amber.Watts.DividedBy(System.Double)">
            <summary>
            Divide this instance by the scalar <paramref name="operand"/>.
            </summary>
            <param name="operand">The number to divide by.</param>
            <returns>A new <see cref="T:Amber.Watts"/> instance that represents this instance's <see cref="F:Amber.Watts.Count"/> divided
            by <paramref name="operand"/>.</returns>
        </member>
        <member name="M:Amber.Watts.MultipliedBy(System.TimeSpan)">
            <summary>
            Multiply this <see cref="T:Amber.Watts"/> instance by the given <see cref="T:System.TimeSpan"/> to produce a new 
            <see cref="T:Amber.KilowattHours"/> instance.
            </summary>
            <param name="operand">The <see cref="T:System.TimeSpan"/> to multiply this power value by.</param>
            <returns>A new <see cref="T:Amber.KilowattHours"/> instance that represents the amount of energy that would
            be obtained from this power level after supplying power for the <see cref="T:System.TimeSpan"/> <paramref name="operand"/>.</returns>
        </member>
        <member name="M:Amber.Watts.op_Addition(Amber.Watts,Amber.Watts)">
            <summary>
            See <see cref="M:Amber.Watts.Plus(Amber.Watts)"/>.
            </summary>
        </member>
        <member name="M:Amber.Watts.op_Subtraction(Amber.Watts,Amber.Watts)">
            <summary>
            See <see cref="M:Amber.Watts.Minus(Amber.Watts)"/>.
            </summary>
        </member>
        <member name="M:Amber.Watts.op_Multiply(Amber.Watts,System.Double)">
            <summary>
            See <see cref="M:Amber.Watts.MultipliedBy(System.Double)"/>.
            </summary>
        </member>
        <member name="M:Amber.Watts.op_Multiply(System.Double,Amber.Watts)">
            <summary>
            See <see cref="M:Amber.Watts.MultipliedBy(System.Double)"/>.
            </summary>
        </member>
        <member name="M:Amber.Watts.op_Division(Amber.Watts,System.Double)">
            <summary>
            See <see cref="M:Amber.Watts.DividedBy(System.Double)"/>.
            </summary>
        </member>
        <member name="M:Amber.Watts.op_UnaryNegation(Amber.Watts)">
            <summary>
            Reverses this instance's <see cref="F:Amber.Watts.Count"/> (same outcome as multiplying this value by -1).
            </summary>
        </member>
        <member name="M:Amber.Watts.op_Multiply(Amber.Watts,System.TimeSpan)">
            <summary>
            See <see cref="M:Amber.Watts.MultipliedBy(System.TimeSpan)"/>.
            </summary>
        </member>
        <member name="M:Amber.Watts.op_Multiply(System.TimeSpan,Amber.Watts)">
            <summary>
            See <see cref="M:Amber.Watts.MultipliedBy(System.TimeSpan)"/>.
            </summary>
        </member>
        <member name="M:Amber.Watts.op_Explicit(System.Double)~Amber.Watts">
            <summary>
            Convert the <paramref name="operand"/> to a <see cref="T:Amber.Watts"/> instance with the same <see cref="F:Amber.Watts.Count"/>.
            </summary>
            <param name="operand">The <see cref="F:Amber.Watts.Count"/> for the new instance.</param>
        </member>
        <member name="M:Amber.Watts.op_Explicit(Amber.Watts)~System.Double">
            <summary>
            Convert the <paramref name="operand"/> to a <see cref="T:System.Double"/> that is
            identical to the <paramref name="operand"/>'s <see cref="F:Amber.Watts.Count"/>.
            </summary>
            <param name="operand">The <see cref="T:Amber.Watts"/> instance to convert.</param>
        </member>
        <member name="M:Amber.Watts.ToString">
            <inheritdoc />
        </member>
        <member name="M:Amber.Watts.Equals(Amber.Watts)">
            <inheritdoc />
        </member>
        <member name="M:Amber.Watts.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Amber.Watts.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Amber.Watts.op_Equality(Amber.Watts,Amber.Watts)">
            <summary>
            See <see cref="M:Amber.Watts.Equals(Amber.Watts)"/>.
            </summary>
        </member>
        <member name="M:Amber.Watts.op_Inequality(Amber.Watts,Amber.Watts)">
            <summary>
            See <see cref="M:Amber.Watts.Equals(Amber.Watts)"/>.
            </summary>
        </member>
        <member name="M:Amber.Watts.CompareTo(Amber.Watts)">
            <inheritdoc />
        </member>
        <member name="M:Amber.Watts.op_GreaterThan(Amber.Watts,Amber.Watts)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.Watts.Count"/>
            is greater than <paramref name="rhs"/>.<see cref="F:Amber.Watts.Count"/>.</returns>
        </member>
        <member name="M:Amber.Watts.op_LessThan(Amber.Watts,Amber.Watts)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.Watts.Count"/>
            is less than <paramref name="rhs"/>.<see cref="F:Amber.Watts.Count"/>.</returns>
        </member>
        <member name="M:Amber.Watts.op_GreaterThanOrEqual(Amber.Watts,Amber.Watts)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.Watts.Count"/>
            is greater than or equal to <paramref name="rhs"/>.<see cref="F:Amber.Watts.Count"/>.</returns>
        </member>
        <member name="M:Amber.Watts.op_LessThanOrEqual(Amber.Watts,Amber.Watts)">
            <summary>
            Compares the quantity of the two instances.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/>.<see cref="F:Amber.Watts.Count"/>
            is less than or equal to <paramref name="rhs"/>.<see cref="F:Amber.Watts.Count"/>.</returns>
        </member>
        <member name="T:Amber.RealBounds">
            <summary>
            Represents a min/max bounding pair of real (<see cref="T:System.Double"/>) numbers.
            </summary>
        </member>
        <member name="F:Amber.RealBounds.Min">
            <summary>
            The minimum/lower bound.
            </summary>
        </member>
        <member name="F:Amber.RealBounds.Max">
            <summary>
            The maximum/upper bound.
            </summary>
        </member>
        <member name="M:Amber.RealBounds.#ctor(System.Double,System.Double)">
            <summary>
            Create a new bounding pair.
            </summary>
            <param name="min">The minimum/lower bound.</param>
            <param name="max">The maximum/upper bound. Must be greater than or equal to min.</param>
        </member>
        <member name="M:Amber.RealBounds.ClampValue(System.Double)">
            <summary>
            Clamp the given value between <see cref="F:Amber.RealBounds.Min"/> and <see cref="F:Amber.RealBounds.Max"/>.
            </summary>
            <param name="value">The value to clamp.</param>
            <returns>The clamped value.</returns>
        </member>
        <member name="T:Amber.IntegerBounds">
            <summary>
            Represents a min/max bounding pair of integer (<see cref="T:System.Int64"/>) numbers.
            </summary>
        </member>
        <member name="F:Amber.IntegerBounds.Min">
            <summary>
            The minimum/lower bound.
            </summary>
        </member>
        <member name="F:Amber.IntegerBounds.Max">
            <summary>
            The maximum/upper bound.
            </summary>
        </member>
        <member name="M:Amber.IntegerBounds.#ctor(System.Int64,System.Int64)">
            <summary>
            Create a new bounding pair.
            </summary>
            <param name="min">The minimum/lower bound.</param>
            <param name="max">The maximum/upper bound. Must be greater than or equal to min.</param>
        </member>
        <member name="M:Amber.IntegerBounds.ClampValue(System.Int64)">
            <summary>
            Clamp the given value between <see cref="F:Amber.IntegerBounds.Min"/> and <see cref="F:Amber.IntegerBounds.Max"/>.
            </summary>
            <param name="value">The value to clamp.</param>
            <returns>The clamped value.</returns>
        </member>
        <member name="T:Amber.UnsignedIntegerBounds">
            <summary>
            Represents a min/max bounding pair of unsigned integer (<see cref="T:System.UInt64"/>) numbers.
            </summary>
        </member>
        <member name="F:Amber.UnsignedIntegerBounds.Min">
            <summary>
            The minimum/lower bound.
            </summary>
        </member>
        <member name="F:Amber.UnsignedIntegerBounds.Max">
            <summary>
            The maximum/upper bound.
            </summary>
        </member>
        <member name="M:Amber.UnsignedIntegerBounds.#ctor(System.UInt64,System.UInt64)">
            <summary>
            Create a new bounding pair.
            </summary>
            <param name="min">The minimum/lower bound.</param>
            <param name="max">The maximum/upper bound. Must be greater than or equal to min.</param>
        </member>
        <member name="M:Amber.UnsignedIntegerBounds.ClampValue(System.UInt64)">
            <summary>
            Clamp the given value between <see cref="F:Amber.UnsignedIntegerBounds.Min"/> and <see cref="F:Amber.UnsignedIntegerBounds.Max"/>.
            </summary>
            <param name="value">The value to clamp.</param>
            <returns>The clamped value.</returns>
        </member>
        <member name="T:Amber.ITimeSeriesDatum">
            <summary>
            Represents a single data point in a collection of data that can be ordered or arranged by a time/timestamp.
            </summary>
        </member>
        <member name="P:Amber.ITimeSeriesDatum.Time">
            <summary>
            The time/timestamp of this datum.
            </summary>
        </member>
        <member name="T:Amber.SetPoint">
            <summary>
            Represents a target value that is approached gradually.
            </summary>
        </member>
        <member name="P:Amber.SetPoint.TargetValue">
            <summary>
            The target value for this set point. If the <see cref="P:Amber.SetPoint.TargetBounds"/> property is set, this value will be
            clamped according to those bounds when set.
            </summary>
        </member>
        <member name="P:Amber.SetPoint.CurrentValue">
            <summary>
            The current value for this set point. When setting this property, the <see cref="P:Amber.SetPoint.MaxDeltaBeforeSnap"/> property
            will be used to snap the value to the <see cref="P:Amber.SetPoint.TargetValue"/> if it is not <c>null</c>.
            </summary>
        </member>
        <member name="P:Amber.SetPoint.RateOfChange">
            <summary>
            The rate of change for this set point (e.g. how fast the <see cref="P:Amber.SetPoint.CurrentValue"/> approaches the <see cref="P:Amber.SetPoint.TargetValue"/>).
            When this property is set, it is automatically converted to a <see cref="P:Amber.Rate.AbsoluteValue"/>.
            </summary>
        </member>
        <member name="P:Amber.SetPoint.TargetBounds">
            <summary>
            The min/max bounds for the <see cref="P:Amber.SetPoint.TargetValue"/>. When this property is set, the <see cref="P:Amber.SetPoint.TargetValue"/> is
            automatically clamped between <see cref="F:Amber.RealBounds.Min"/> and <see cref="F:Amber.RealBounds.Max"/>. Set to <c>null</c> to
            indicate no min/max.
            </summary>
        </member>
        <member name="P:Amber.SetPoint.MaxDeltaBeforeSnap">
            <summary>
            The maximum delta (difference between <see cref="P:Amber.SetPoint.CurrentValue"/> and <see cref="P:Amber.SetPoint.TargetValue"/>) before the 
            <see cref="P:Amber.SetPoint.CurrentValue"/> is snapped to the <see cref="P:Amber.SetPoint.TargetValue"/>). Set to <c>null</c> to disable snapping.
            </summary>
        </member>
        <member name="M:Amber.SetPoint.#ctor(System.Double,System.Double,Amber.Rate)">
            <summary>
            Create a new set point with the given <paramref name="startingValue"/>, <paramref name="targetValue"/>,
            and <paramref name="rateOfChange"/>.
            </summary>
            <param name="startingValue">The initial <see cref="P:Amber.SetPoint.CurrentValue"/>.</param>
            <param name="targetValue">The initial <see cref="P:Amber.SetPoint.TargetValue"/>.</param>
            <param name="rateOfChange">The rate of change for this set point (e.g. how fast the <see cref="P:Amber.SetPoint.CurrentValue"/>
            approaches the <see cref="P:Amber.SetPoint.TargetValue"/>).</param>
        </member>
        <member name="M:Amber.SetPoint.#ctor(System.Double,System.Double,Amber.RealBounds,Amber.Rate)">
            <summary>
            Create a new set point with the given <paramref name="startingValue"/>, <paramref name="targetValue"/>,
            <paramref name="targetBounds"/> and <paramref name="rateOfChange"/>.
            </summary>
            <param name="startingValue">The initial <see cref="P:Amber.SetPoint.CurrentValue"/>.</param>
            <param name="targetValue">The initial <see cref="P:Amber.SetPoint.TargetValue"/>.</param>
            <param name="targetBounds">The min/max bounds for the <see cref="P:Amber.SetPoint.TargetValue"/>. The given <paramref name="targetValue"/>
            will be automatically clamped between <see cref="F:Amber.RealBounds.Min"/> and <see cref="F:Amber.RealBounds.Max"/>.</param>
            <param name="rateOfChange">The rate of change for this set point (e.g. how fast the <see cref="P:Amber.SetPoint.CurrentValue"/>
            approaches the <see cref="P:Amber.SetPoint.TargetValue"/>).</param>
        </member>
        <member name="M:Amber.SetPoint.ProgressTime(System.TimeSpan)">
            <summary>
            Tick/progress time for this set point. The <see cref="P:Amber.SetPoint.CurrentValue"/> will approach the <see cref="P:Amber.SetPoint.TargetValue"/>
            according to the given <paramref name="deltaTime"/> and <see cref="P:Amber.SetPoint.RateOfChange"/>. If the <see cref="P:Amber.SetPoint.CurrentValue"/>
            reaches or exceeds the <see cref="P:Amber.SetPoint.TargetValue"/>, or falls within the <see cref="P:Amber.SetPoint.MaxDeltaBeforeSnap"/>, it will be clamped
            to <see cref="P:Amber.SetPoint.TargetValue"/>.
            </summary>
            <param name="deltaTime">The amount of time to progress the <see cref="P:Amber.SetPoint.CurrentValue"/> by.</param>
        </member>
        <member name="T:Amber.Rate">
            <summary>
            Represents a value quantified (chunked/split up) by time (e.g. "8 kilowatts per hour" or "300 rows per minute").
            </summary>
        </member>
        <member name="F:Amber.Rate.Zero">
            <summary>
            A <see cref="T:Amber.Rate"/> whose <see cref="F:Amber.Rate.Amount"/> is <c>0</c> and whose <see cref="F:Amber.Rate.TimeSpan"/>
            is <see cref="F:System.TimeSpan.Zero"/>.
            </summary>
        </member>
        <member name="F:Amber.Rate.Amount">
            <summary>
            The quantified value/amount.
            </summary>
        </member>
        <member name="F:Amber.Rate.TimeSpan">
            <summary>
            The quantifying time span.
            </summary>
        </member>
        <member name="P:Amber.Rate.AbsoluteValue">
            <summary>
            Returns this <see cref="T:Amber.Rate"/> as an absolute delta. For example, "-600 per hour" becomes
            "600 per hour".
            </summary>
        </member>
        <member name="P:Amber.Rate.Reversed">
            <summary>
            Returns the reverse/negative of this <see cref="T:Amber.Rate"/>. For example, "100 per second" becomes
            "-100 per second".
            </summary>
        </member>
        <member name="P:Amber.Rate.Inverted">
            <summary>
            Returns a <see cref="T:Amber.Rate"/> with the same absolute value, but in the opposite temporal direction.
            For example, "30 every 10 minutes" becomes "-30 every -10 minutes".
            </summary>
        </member>
        <member name="P:Amber.Rate.TimeSpanForExactlyOne">
            <summary>
            Get the <see cref="F:Amber.Rate.TimeSpan"/> required for a value of exactly 1. Equivalent to calling <see cref="M:Amber.Rate.GetTimeSpanForValue(System.Double)"/>
            with the parameter <c>1d</c>.
            </summary>
        </member>
        <member name="P:Amber.Rate.EachMillisecond">
            <summary>
            Get the value given by this rate per millisecond. Equivalent to calling <see cref="M:Amber.Rate.GetValueForTimeSpan(System.TimeSpan)"/> with the
            parameter <c>TimeSpan.FromMilliseconds(1d)</c>.
            </summary>
        </member>
        <member name="P:Amber.Rate.EachSecond">
            <summary>
            Get the value given by this rate per second. Equivalent to calling <see cref="M:Amber.Rate.GetValueForTimeSpan(System.TimeSpan)"/> with the
            parameter <c>TimeSpan.FromSeconds(1d)</c>.
            </summary>
        </member>
        <member name="P:Amber.Rate.EachMinute">
            <summary>
            Get the value given by this rate per minute. Equivalent to calling <see cref="M:Amber.Rate.GetValueForTimeSpan(System.TimeSpan)"/> with the
            parameter <c>TimeSpan.FromMinutes(1d)</c>.
            </summary>
        </member>
        <member name="P:Amber.Rate.EachHour">
            <summary>
            Get the value given by this rate per hour. Equivalent to calling <see cref="M:Amber.Rate.GetValueForTimeSpan(System.TimeSpan)"/> with the
            parameter <c>TimeSpan.FromHours(1d)</c>.
            </summary>
        </member>
        <member name="P:Amber.Rate.EachDay">
            <summary>
            Get the value given by this rate per day. Equivalent to calling <see cref="M:Amber.Rate.GetValueForTimeSpan(System.TimeSpan)"/> with the
            parameter <c>TimeSpan.FromDays(1d)</c>.
            </summary>
        </member>
        <member name="M:Amber.Rate.#ctor(System.Double,System.TimeSpan)">
            <summary>
            Create a new <see cref="T:Amber.Rate"/>. If <paramref name="amount"/> or <paramref name="timeSpan"/>
            are zero, <see cref="F:Amber.Rate.Zero"/> will be set for the entire struct.
            </summary>
            <param name="amount">The quantified value/amount.</param>
            <param name="timeSpan">The quantifying time span.</param>
        </member>
        <member name="M:Amber.Rate.PerMillisecond(System.Double)">
            <summary>
            Create a new <see cref="T:Amber.Rate"/> that represents the given <paramref name="amount"/> every millisecond.
            </summary>
            <param name="amount">The amount-per-millisecond of this <see cref="T:Amber.Rate"/>.</param>
            <returns>A new <see cref="T:Amber.Rate"/> whose <see cref="F:Amber.Rate.Amount"/> is <paramref name="amount"/>
            and whose <see cref="F:Amber.Rate.TimeSpan"/> is equivalent to <c>TimeSpan.FromMilliseconds(1)</c>.</returns>
        </member>
        <member name="M:Amber.Rate.PerSecond(System.Double)">
            <summary>
            Create a new <see cref="T:Amber.Rate"/> that represents the given <paramref name="amount"/> every second.
            </summary>
            <param name="amount">The amount-per-second of this <see cref="T:Amber.Rate"/>.</param>
            <returns>A new <see cref="T:Amber.Rate"/> whose <see cref="F:Amber.Rate.Amount"/> is <paramref name="amount"/>
            and whose <see cref="F:Amber.Rate.TimeSpan"/> is equivalent to <c>TimeSpan.FromSeconds(1)</c>.</returns>
        </member>
        <member name="M:Amber.Rate.PerMinute(System.Double)">
            <summary>
            Create a new <see cref="T:Amber.Rate"/> that represents the given <paramref name="amount"/> every minute.
            </summary>
            <param name="amount">The amount-per-minute of this <see cref="T:Amber.Rate"/>.</param>
            <returns>A new <see cref="T:Amber.Rate"/> whose <see cref="F:Amber.Rate.Amount"/> is <paramref name="amount"/>
            and whose <see cref="F:Amber.Rate.TimeSpan"/> is equivalent to <c>TimeSpan.FromMinutes(1)</c>.</returns>
        </member>
        <member name="M:Amber.Rate.PerHour(System.Double)">
            <summary>
            Create a new <see cref="T:Amber.Rate"/> that represents the given <paramref name="amount"/> every hour.
            </summary>
            <param name="amount">The amount-per-hour of this <see cref="T:Amber.Rate"/>.</param>
            <returns>A new <see cref="T:Amber.Rate"/> whose <see cref="F:Amber.Rate.Amount"/> is <paramref name="amount"/>
            and whose <see cref="F:Amber.Rate.TimeSpan"/> is equivalent to <c>TimeSpan.FromHours(1)</c>.</returns>
        </member>
        <member name="M:Amber.Rate.PerDay(System.Double)">
            <summary>
            Create a new <see cref="T:Amber.Rate"/> that represents the given <paramref name="amount"/> every day.
            </summary>
            <param name="amount">The amount-per-day of this <see cref="T:Amber.Rate"/>.</param>
            <returns>A new <see cref="T:Amber.Rate"/> whose <see cref="F:Amber.Rate.Amount"/> is <paramref name="amount"/>
            and whose <see cref="F:Amber.Rate.TimeSpan"/> is equivalent to <c>TimeSpan.FromDays(1)</c>.</returns>
        </member>
        <member name="M:Amber.Rate.WithPositiveTimeSpan">
            <summary>
            Gets a <see cref="T:Amber.Rate"/> with the same absolute value but a positive <see cref="F:Amber.Rate.TimeSpan"/>.
            </summary>
            <returns>If this <see cref="T:Amber.Rate"/>'s <see cref="F:Amber.Rate.TimeSpan"/> is currently negative, returns this
            value <see cref="P:Amber.Rate.Inverted"/>. Otherwise, simply returns this value.</returns>
        </member>
        <member name="M:Amber.Rate.WithNegativeTimeSpan">
            <summary>
            Gets a <see cref="T:Amber.Rate"/> with the same absolute value but a negative <see cref="F:Amber.Rate.TimeSpan"/>.
            </summary>
            <returns>If this <see cref="T:Amber.Rate"/>'s <see cref="F:Amber.Rate.TimeSpan"/> is currently positive, returns this
            value <see cref="P:Amber.Rate.Inverted"/>. Otherwise, simply returns this value.</returns>
        </member>
        <member name="M:Amber.Rate.GetValueForTimeSpan(System.TimeSpan)">
            <summary>
            Get the quantified value for the given <paramref name="timeSpan"/>.
            </summary>
            <param name="timeSpan">The <see cref="T:System.TimeSpan"/> to get a value for.</param>
            <returns>The amount/value that this <see cref="T:Amber.Rate"/> represents for the given <paramref name="timeSpan"/>.</returns>
        </member>
        <member name="M:Amber.Rate.GetTimeSpanForValue(System.Double)">
            <summary>
            Get the <see cref="T:System.TimeSpan"/> that would represent the given <paramref name="value"/> for this
            <see cref="T:Amber.Rate"/>.
            </summary>
            <param name="value">The value to get a <see cref="T:System.TimeSpan"/> for.</param>
            <returns>The <see cref="T:System.TimeSpan"/> that would represent the given <paramref name="value"/>
            for this <see cref="T:Amber.Rate"/>.</returns>
        </member>
        <member name="M:Amber.Rate.MultipliedBy(System.Double)">
            <summary>
            Multiplies the <see cref="F:Amber.Rate.Amount"/> of this <see cref="T:Amber.Rate"/>, leaving the <see cref="F:Amber.Rate.TimeSpan"/>
            as-is.
            </summary>
            <param name="operand">The multiplication factor.</param>
            <returns>A new <see cref="T:Amber.Rate"/> with a multiplied <see cref="F:Amber.Rate.Amount"/>.</returns>
        </member>
        <member name="M:Amber.Rate.DividedBy(System.Double)">
            <summary>
            Divides the <see cref="F:Amber.Rate.Amount"/> of this <see cref="T:Amber.Rate"/>, leaving the <see cref="F:Amber.Rate.TimeSpan"/>
            as-is.
            </summary>
            <param name="operand">The denominator.</param>
            <returns>A new <see cref="T:Amber.Rate"/> with a divided <see cref="F:Amber.Rate.Amount"/>.</returns>
        </member>
        <member name="M:Amber.Rate.IncreasedBy(System.Double)">
            <summary>
            Linearly increases the <see cref="F:Amber.Rate.Amount"/> of this <see cref="T:Amber.Rate"/>, leaving the <see cref="F:Amber.Rate.TimeSpan"/>
            as-is.
            </summary>
            <param name="operand">The increment amount.</param>
            <returns>A new <see cref="T:Amber.Rate"/> with an incremented <see cref="F:Amber.Rate.Amount"/>.</returns>
        </member>
        <member name="M:Amber.Rate.DecreasedBy(System.Double)">
            <summary>
            Linearly decreases the <see cref="F:Amber.Rate.Amount"/> of this <see cref="T:Amber.Rate"/>, leaving the <see cref="F:Amber.Rate.TimeSpan"/>
            as-is.
            </summary>
            <param name="operand">The decrement amount.</param>
            <returns>A new <see cref="T:Amber.Rate"/> with an decremented <see cref="F:Amber.Rate.Amount"/>.</returns>
        </member>
        <member name="M:Amber.Rate.Plus(Amber.Rate)">
            <summary>
            Adds this <see cref="T:Amber.Rate"/> to the given <paramref name="operand"/>. For example, "100 every 10sec" plus
            "300 every 30sec" will return "200 every 10sec".
            </summary>
            <param name="operand">The rate to add to this one.</param>
            <returns>A new <see cref="T:Amber.Rate"/> that represents the two input rates combined.</returns>
        </member>
        <member name="M:Amber.Rate.Minus(Amber.Rate)">
            <summary>
            Subtracts the <paramref name="operand"/> from this <see cref="T:Amber.Rate"/>. For example, "200 every 20sec" minus
            "300 every 60sec" will return "100 every 20sec".
            </summary>
            <param name="operand">The rate to subtract from this one.</param>
            <returns>A new <see cref="T:Amber.Rate"/> that represents the difference of the two input rates.</returns>
        </member>
        <member name="M:Amber.Rate.Equals(Amber.Rate)">
            <summary>
            Ascertains whether or not this and <paramref name="other"/> represent identical <see cref="T:Amber.Rate"/>s. The two operands
            do not need to be bitwise-equal; for example "100 per 10sec" and "200 per 20sec" will be considered equal.
            </summary>
            <param name="other">The <see cref="T:Amber.Rate"/> to compare against.</param>
            <returns><c>True</c> if both inputs represent equal rates.</returns>
        </member>
        <member name="M:Amber.Rate.CompareTo(Amber.Rate)">
            <inheritdoc />
        </member>
        <member name="M:Amber.Rate.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Amber.Rate.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Amber.Rate.ToString">
            <inheritdoc />
        </member>
        <member name="M:Amber.Rate.op_Equality(Amber.Rate,Amber.Rate)">
            <summary>
            <see cref="M:Amber.Rate.Equals(Amber.Rate)"/>.
            </summary>
        </member>
        <member name="M:Amber.Rate.op_Inequality(Amber.Rate,Amber.Rate)">
            <summary>
            <see cref="M:Amber.Rate.Equals(Amber.Rate)"/>.
            </summary>
        </member>
        <member name="M:Amber.Rate.op_UnaryNegation(Amber.Rate)">
            <summary>
            <see cref="P:Amber.Rate.Reversed"/>.
            </summary>
        </member>
        <member name="M:Amber.Rate.op_Multiply(Amber.Rate,System.Double)">
            <summary>
            <see cref="M:Amber.Rate.MultipliedBy(System.Double)"/>.
            </summary>
        </member>
        <member name="M:Amber.Rate.op_Multiply(System.Double,Amber.Rate)">
            <summary>
            <see cref="M:Amber.Rate.MultipliedBy(System.Double)"/>.
            </summary>
        </member>
        <member name="M:Amber.Rate.op_Division(Amber.Rate,System.Double)">
            <summary>
            <see cref="M:Amber.Rate.DividedBy(System.Double)"/>.
            </summary>
        </member>
        <member name="M:Amber.Rate.op_Addition(Amber.Rate,System.Double)">
            <summary>
            <see cref="M:Amber.Rate.IncreasedBy(System.Double)"/>.
            </summary>
        </member>
        <member name="M:Amber.Rate.op_Addition(System.Double,Amber.Rate)">
            <summary>
            <see cref="M:Amber.Rate.IncreasedBy(System.Double)"/>.
            </summary>
        </member>
        <member name="M:Amber.Rate.op_Subtraction(Amber.Rate,System.Double)">
            <summary>
            <see cref="M:Amber.Rate.IncreasedBy(System.Double)"/>.
            </summary>
        </member>
        <member name="M:Amber.Rate.op_Addition(Amber.Rate,Amber.Rate)">
            <summary>
            <see cref="M:Amber.Rate.Plus(Amber.Rate)"/>.
            </summary>
        </member>
        <member name="M:Amber.Rate.op_Subtraction(Amber.Rate,Amber.Rate)">
            <summary>
            <see cref="M:Amber.Rate.Minus(Amber.Rate)"/>.
            </summary>
        </member>
        <member name="M:Amber.Rate.op_Multiply(Amber.Rate,System.TimeSpan)">
            <summary>
            <see cref="M:Amber.Rate.GetValueForTimeSpan(System.TimeSpan)"/>.
            </summary>
        </member>
        <member name="M:Amber.Rate.op_GreaterThan(Amber.Rate,Amber.Rate)">
            <summary>
            Compares the speed/strength of the two <see cref="T:Amber.Rate"/>s.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/> represents a faster/stronger rate than <paramref name="rhs"/>.</returns>
        </member>
        <member name="M:Amber.Rate.op_LessThan(Amber.Rate,Amber.Rate)">
            <summary>
            Compares the speed/strength of the two <see cref="T:Amber.Rate"/>s.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/> represents a slower/weaker rate than <paramref name="rhs"/>.</returns>
        </member>
        <member name="M:Amber.Rate.op_GreaterThanOrEqual(Amber.Rate,Amber.Rate)">
            <summary>
            Compares the speed/strength of the two <see cref="T:Amber.Rate"/>s.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/> represents a faster/stronger or equal rate compared to <paramref name="rhs"/>.</returns>
        </member>
        <member name="M:Amber.Rate.op_LessThanOrEqual(Amber.Rate,Amber.Rate)">
            <summary>
            Compares the speed/strength of the two <see cref="T:Amber.Rate"/>s.
            </summary>
            <param name="lhs">The left-hand operand.</param>
            <param name="rhs">The right-hand operand.</param>
            <returns><c>True</c> if <paramref name="lhs"/> represents a slower/weaker or equal rate compared to <paramref name="rhs"/>.</returns>
        </member>
        <member name="T:Amber.DateAndTimeUtils">
            <summary>
            Series of static util methods that add additional functionality for working with date and time.
            </summary>
        </member>
        <member name="F:Amber.DateAndTimeUtils.ZeroTimeSpanHumanReadableString">
            <summary>
            The string emitted by <see cref="M:Amber.DateAndTimeUtils.ConvertToHumanReadableString(System.TimeSpan)"/> when the given <see cref="T:System.TimeSpan"/>
            is <see cref="F:System.TimeSpan.Zero"/>.
            </summary>
        </member>
        <member name="M:Amber.DateAndTimeUtils.ConvertToHumanReadableString(System.TimeSpan)">
            <summary>
            Convert the given <paramref name="timeSpan"/> in to a human-readable string format 
            (e.g. "<c>4 days, 10 hours, 30 mins, 10 secs, 500 ms</c>").
            </summary>
            <param name="timeSpan">The <see cref="T:System.TimeSpan"/> to convert to a string.</param>
            <returns>A new string in human readable format.</returns>
        </member>
        <member name="M:Amber.DateAndTimeUtils.ConvertFromHumanReadableString(System.String)">
            <summary>
            Convert a string that represents a human-readable <see cref="T:System.TimeSpan"/>
            (in "<c>4 days, 10 hours, 30 mins, 10 secs, 500 ms</c>" format) to an actual <see cref="T:System.TimeSpan"/>.
            </summary>
            <param name="humanReadableString">The human-readable timespan string.</param>
            <returns>A <see cref="T:System.TimeSpan"/> that the given <paramref name="humanReadableString"/> represents.</returns>
        </member>
    </members>
</doc>
